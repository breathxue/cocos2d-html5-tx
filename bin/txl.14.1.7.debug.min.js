///<reference path='../ImportTS.d.ts' />
function trace() {
    var args = [];
    for (var _i = 0; _i < (arguments.length - 0); _i++) {
        args[_i] = arguments[_i + 0];
    }
    var out = "";
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (arg instanceof cc.Point) {
            out += "(" + arg.x + "," + arg.y + ")" + " ";
        } else {
            out += arg + " ";
        }
    }
    cc.log(out);
}
var tx;
(function (tx) {
    /**
    * Created with JetBrains WebStorm.
    * User: admin
    * Date: 13-9-27
    * Time: 下午3:47
    * To change this template use File | Settings | File Templates.
    */
    (function (ev) {
        var Event = (function () {
            function Event(type) {
                this.type = type;
            }
            Event.ENTER_FRAME = "ENTER_FRAME";
            return Event;
        })();
        ev.Event = Event;
    })(tx.ev || (tx.ev = {}));
    var ev = tx.ev;
})(tx || (tx = {}));
var tx;
(function (tx) {
    ///<reference path='Event.ts' />
    /**
    * Created with JetBrains WebStorm.
    * User: admin
    * Date: 13-9-27
    * Time: 下午3:47
    * To change this template use File | Settings | File Templates.
    */
    (function (ev) {
        var EventDispatcher = (function () {
            function EventDispatcher(target) {
                this._eventHandlers = {};
                this._target = target;
                if (this._target == null) {
                    this._target = this;
                }
            }
            EventDispatcher.prototype.destroy = function () {
                this._target = null;
                this._eventHandlers = null;
            };

            // maintain a list of listeners
            EventDispatcher.prototype.addEventListener = function (eventType, theHandler) {
                this._eventHandlers[eventType] = this._eventHandlers[eventType] || [];
                this._eventHandlers[eventType].push(theHandler);
            };

            // remove a listener
            EventDispatcher.prototype.removeEventListener = function (eventType, theHandler) {
                this._eventHandlers[eventType] = this._eventHandlers[eventType] || [];
                var theHandlers = this._eventHandlers[eventType];
                if (theHandlers) {
                    for (var i = 0; i < theHandlers.length; i += 1) {
                        theHandlers.splice(i, 1);
                        return;
                    }
                }
            };

            // remove all listeners
            EventDispatcher.prototype.removeAllListeners = function (eventType) {
                this._eventHandlers[eventType] = [];
            };

            // dispatch event to all listeners
            EventDispatcher.prototype.dispatchEvent = function (theEvent) {
                theEvent.target = this._target;
                var theHandlers = this._eventHandlers[theEvent.type];
                if (theHandlers) {
                    for (var i = 0; i < theHandlers.length; i += 1) {
                        this.dispatchEventToHander(theEvent, theHandlers[i]);
                    }
                }
            };

            // send event to a handler
            EventDispatcher.prototype.dispatchEventToHander = function (theEvent, theHandler) {
                theHandler(theEvent);
            };
            return EventDispatcher;
        })();
        ev.EventDispatcher = EventDispatcher;
    })(tx.ev || (tx.ev = {}));
    var ev = tx.ev;
})(tx || (tx = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var tx;
(function (tx) {
    ///<reference path='../ImportTs.d.ts' />
    (function (ev) {
        var MouseTouchEvent = (function (_super) {
            __extends(MouseTouchEvent, _super);
            function MouseTouchEvent(type, pos) {
                _super.call(this, type);
                this.pos = pos;
            }
            MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN = "MOUSE_DOWN_TOUCH_BEGAN";
            MouseTouchEvent.MOUSE_UP_TOUCH_ENDED = "MOUSE_UP_TOUCH_ENDED";
            MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE = "MOUSE_DRAGGED_TOUCH_MOVE";
            MouseTouchEvent.MOUSE_TOUCH_OVER = "MOUSE_TOUCH_OVER";
            MouseTouchEvent.MOUSE_TOUCH_OUT = "MOUSE_TOUCH_OUT";
            return MouseTouchEvent;
        })(tx.ev.Event);
        ev.MouseTouchEvent = MouseTouchEvent;
    })(tx.ev || (tx.ev = {}));
    var ev = tx.ev;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    function interactiveObjectCreate(mc, listerOb) {
        var t1 = mc;
        var t2 = listerOb;
        var same = false;
        if (t1 == t2) {
            same = true;
        }
        if ('mouse' in sys.capabilities) {
            mc.setMouseEnabled(true);
        } else {
            cc.log("MOUSE Not supported");
        }

        if ('touches' in sys.capabilities) {
            // listerOb is the default behavior. No need to set it explicitly.
            //            mc.setTouchMode(cc.TOUCH_ALL_AT_ONCE);
            mc.setTouchMode(cc.TOUCH_ONE_BY_ONE);
            mc.setTouchEnabled(true);
        } else {
            cc.log("TOUCHES not supported");
        }

        //重写的回调函数,记录上一次的回调函数
        var tempFunctionBegan = mc.onTouchesBegan;
        mc.onTouchesBegan = function (touches, event) {
            if (touches.length > 0) {
                if (!same) {
                    listerOb.onTouchBegan(touches[0], event);
                }
                listerOb.onMouseDownTouchBegan(touches[0].getLocation());
            }
            if (!same) {
                listerOb.onTouchesBegan(touches, event);
            }
            tempFunctionBegan(touches, event);
            return true;
        };
        mc.onTouchesBegan["lastCallBack"] = tempFunctionBegan;

        var tempFunctionEnded = mc.onTouchesEnded;
        mc.onTouchesEnded = function (touches, event) {
            if (touches.length > 0) {
                if (!same) {
                    listerOb.onTouchEnded(touches[0], event);
                }
                listerOb.onMouseTouchEndedUp(touches[0].getLocation());
            }
            if (!same) {
                listerOb.onTouchesEnded(touches, event);
            }
            tempFunctionEnded(touches, event);
            return true;
        };
        mc.onTouchesEnded["lastCallBack"] = tempFunctionEnded;

        var tempFunctionTouchesMoved = mc.onTouchesMoved;
        mc.onTouchesMoved = function (touches, event) {
            //            cc.log("onTouchesMoved");
            if (touches.length > 0) {
                if (!same) {
                    listerOb.onTouchMoved(touches[0], event);
                }
                listerOb.onMouseDraggedTouchMove(touches[0].getLocation());
            }
            if (!same) {
                listerOb.onTouchesMoved(touches, event);
            }
            tempFunctionTouchesMoved(touches, event);
            return true;
        };
        mc.onTouchesMoved["lastCallBack"] = tempFunctionTouchesMoved;

        var tempFunctionTouchBegan = mc.onTouchBegan;
        mc.onTouchBegan = function (touch, event) {
            if (!same) {
                listerOb.onTouchBegan(touch, event);
            }
            listerOb.onMouseDownTouchBegan(touch.getLocation());
            tempFunctionTouchBegan(touch, event);
            return true;
        };
        mc.onTouchBegan["lastCallBack"] = tempFunctionTouchBegan;

        var tempFunctionTouchEnded = mc.onTouchEnded;
        mc.onTouchEnded = function (touch, event) {
            if (!same) {
                listerOb.onTouchEnded(touch, event);
            }
            listerOb.onMouseTouchEndedUp(touch.getLocation());
            tempFunctionTouchEnded(touch, event);
            return true;
        };
        mc.onTouchEnded["lastCallBack"] = tempFunctionTouchEnded;

        var tempFunctionTouchMoved = mc.onTouchMoved;
        mc.onTouchMoved = function (touch, event) {
            if (!same) {
                listerOb.onTouchMoved(touch, event);
            }
            listerOb.onMouseDraggedTouchMove(touch.getLocation());
            tempFunctionTouchMoved(touch, event);
            return true;
        };
        mc.onTouchMoved["lastCallBack"] = tempFunctionTouchMoved;

        var tempFunctionMouseDown = mc.onMouseDown;
        mc.onMouseDown = function (event) {
            if (!same) {
                listerOb.onMouseDown(event);
            }
            listerOb.onMouseDownTouchBegan(event.getLocation());
            tempFunctionMouseDown(event);
            return true;
        };
        mc.onMouseDown["lastCallBack"] = tempFunctionMouseDown;

        var tempFunctionMouseUp = mc.onMouseUp;
        mc.onMouseUp = function (event) {
            if (!same) {
                listerOb.onMouseUp(event);
            }
            listerOb.onMouseTouchEndedUp(event.getLocation());
            tempFunctionMouseUp(event);
            return true;
        };
        mc.onMouseUp["lastCallBack"] = tempFunctionMouseUp;

        var tempFunctionMouseDragged = mc.onMouseDragged;
        mc.onMouseDragged = function (event) {
            //            cc.log("onMouseDragged");
            if (!same) {
                listerOb.onMouseDragged(event);
            }
            listerOb.onMouseDraggedTouchMove(event.getLocation());
            tempFunctionMouseDragged(event);
            return true;
        };
        mc.onMouseDragged["lastCallBack"] = tempFunctionMouseDragged;
    }
    tx.interactiveObjectCreate = interactiveObjectCreate;

    function interactiveObjectRemove(mc) {
        mc.onTouchesEnded = mc.onTouchesEnded["lastCallBack"];
        mc.onTouchesBegan = mc.onTouchesBegan["lastCallBack"];
        mc.onTouchesMoved = mc.onTouchesMoved["lastCallBack"];

        mc.onTouchBegan = mc.onTouchBegan["lastCallBack"];
        mc.onTouchEnded = mc.onTouchEnded["lastCallBack"];
        mc.onTouchMoved = mc.onTouchMoved["lastCallBack"];

        mc.onMouseDown = mc.onMouseDown["lastCallBack"];
        mc.onMouseUp = mc.onMouseUp["lastCallBack"];
        mc.onMouseDragged = mc.onMouseDragged["lastCallBack"];
    }
    tx.interactiveObjectRemove = interactiveObjectRemove;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var InteractiveObject = (function (_super) {
        __extends(InteractiveObject, _super);
        function InteractiveObject(mc) {
            _super.call(this);
            this._mc = mc;
            tx.interactiveObjectCreate(this._mc, this);
        }
        InteractiveObject.prototype.destroy = function () {
            tx.interactiveObjectRemove(this._mc);
            this._mc = null;
            _super.prototype.destroy.call(this);
        };

        InteractiveObject.prototype.getMc = function () {
            return this._mc;
        };

        InteractiveObject.prototype.onMouseDown = function (event) {
        };

        InteractiveObject.prototype.onMouseDragged = function (event) {
        };

        InteractiveObject.prototype.onMouseUp = function (event) {
        };

        InteractiveObject.prototype.onTouchBegan = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchMoved = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchEnded = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchesBegan = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchesMoved = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchesEnded = function (touch, event) {
        };

        InteractiveObject.prototype.onMouseDownTouchBegan = function (pos) {
        };

        InteractiveObject.prototype.onMouseTouchEndedUp = function (pos) {
        };

        InteractiveObject.prototype.onMouseDraggedTouchMove = function (pos) {
        };
        return InteractiveObject;
    })(tx.ev.EventDispatcher);
    tx.InteractiveObject = InteractiveObject;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var DragObject = (function (_super) {
        __extends(DragObject, _super);
        function DragObject(mc, fixedPos) {
            _super.call(this, mc);
            this._fixedPos = fixedPos;
            this._startDragStartPos = mc.getPosition();
        }
        DragObject.StartDrag = function (mc) {
            DragObject.EndDrag(mc);
            var temp = new DragObject(mc, true);
            DragObject._dragHander.push(temp);
        };

        DragObject.EndDrag = function (mc) {
            for (var i = 0; i < DragObject._dragHander.length; i++) {
                if (DragObject._dragHander[i].getMc() == mc) {
                    DragObject._dragHander[i].destroy();
                    DragObject._dragHander.splice(i, 1);
                    return;
                }
            }
        };

        DragObject.SetToDragObject = function (mc) {
            DragObject.RemoveDragObject(mc);
            var temp = new DragObject(mc);
            DragObject._setDragHander.push(temp);
        };

        DragObject.RemoveDragObject = function (mc) {
            for (var i = 0; i < DragObject._setDragHander.length; i++) {
                if (DragObject._setDragHander[i].getMc() == mc) {
                    DragObject._setDragHander[i].destroy();
                    DragObject._setDragHander.splice(i, 1);
                    return;
                }
            }
        };

        DragObject.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
        };

        DragObject.prototype.onMouseDownTouchBegan = function (pos) {
            if (!this._fixedPos) {
                this._startDragStartMousePos = new cc.Point(pos.x, pos.y);
                this._startDragStartPos = this._mc.getPosition();
            }
        };

        DragObject.prototype.onMouseTouchEndedUp = function (pos) {
            if (!this._fixedPos) {
                this._startDragStartMousePos = null;
            }
        };

        DragObject.prototype.onMouseDraggedTouchMove = function (pos) {
            if (this._startDragStartMousePos == null) {
                this._startDragStartMousePos = new cc.Point(pos.x, pos.y);
            }
            var post = new cc.Point(pos.x, pos.y);
            post.x -= this._startDragStartMousePos.x;
            post.y -= this._startDragStartMousePos.y;
            this._mc.setPositionX(this._startDragStartPos.x + post.x);
            this._mc.setPositionY(this._startDragStartPos.y + post.y);
        };
        DragObject._dragHander = new Array();
        DragObject._setDragHander = new Array();
        return DragObject;
    })(tx.InteractiveObject);
    tx.DragObject = DragObject;
})(tx || (tx = {}));
///<reference path='../ImportTs.d.ts' />
var tx;
(function (tx) {
    var Bitmap = (function (_super) {
        __extends(Bitmap, _super);
        function Bitmap(bmd) {
            _super.call(this);
            this._mouseEnable = false;
            this._isOver = false;
            this._opacity = 255;
            this.setBitmapData(bmd);
            this._ed = new tx.ev.EventDispatcher(this);
            //return true;
        }
        Bitmap.prototype.setBitmapData = function (bmd) {
            this._bmd = bmd;
            //            this._AnchorOffPoint = cc.p(-this._bmd.getWidth()*this.getAnchorPoint().x, -this._bmd.getHeight()*this.getAnchorPoint().y);
        };

        Bitmap.prototype.getBitmapData = function () {
            return this._bmd;
        };

        Bitmap.prototype.draw = function (ctx) {
            if (this._bmd != null) {
                ctx.globalAlpha = this.getOpacity() / 255.0;
                cc.drawingUtil.drawImage(this._bmd._getImageEle(), cc.p(0, 0)); //this._AnchorOffPoint);
            }
        };

        Bitmap.prototype.getOpacity = function () {
            return this._opacity;
        };

        Bitmap.prototype.setOpacity = function (t) {
            this._opacity = t;
        };

        //        setAnchorPoint(pos:cc.Point):void
        //        {
        //            super.setAnchorPoint(pos);
        //            this._AnchorOffPoint = cc.p(-this._bmd.getWidth()*this.getAnchorPoint().x, -this._bmd.getHeight()*this.getAnchorPoint().y);
        //        }
        Bitmap.prototype.setMouseTouchEnabled = function (b) {
            if (this._mouseEnable != b) {
                this._mouseEnable = b;
                if (b) {
                    trace("fffffffffffff");
                    tx.interactiveObjectCreate(this, this);
                } else {
                    tx.interactiveObjectRemove(this);
                }
            }
        };

        Bitmap.prototype.getMouseTouchEnabled = function () {
            return this._mouseEnable;
        };

        Bitmap.prototype.addEventListener = function (eventType, theHandler) {
            this._ed.addEventListener(eventType, theHandler);
        };

        // remove a listener
        Bitmap.prototype.removeEventListener = function (eventType, theHandler) {
            this._ed.removeEventListener(eventType, theHandler);
        };

        // remove all listeners
        Bitmap.prototype.removeAllListeners = function (eventType) {
            this._ed.removeAllListeners(eventType);
        };

        // dispatch event to all listeners
        Bitmap.prototype.dispatchEvent = function (theEvent) {
            this._ed.dispatchEvent(theEvent);
        };

        // send event to a handler
        Bitmap.prototype.dispatchEventToHander = function (theEvent, theHandler) {
            this._ed.dispatchEventToHander(theEvent, theHandler);
        };

        Bitmap.prototype.onMouseDownTouchBegan = function (pos) {
            //            trace("onMouseDownTouchBegan");
            var local = this.convertToNodeSpace(pos);
            var t = this._bmd.getPixel4B(local.x, this._bmd.getHeight() - local.y);

            //            trace(t.a);
            if (t.a > 0) {
                var e = new tx.ev.MouseTouchEvent(tx.ev.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, local);
                this._ed.dispatchEvent(e);
            }
        };

        Bitmap.prototype.onMouseTouchEndedUp = function (pos) {
            //            trace("onMouseTouchEndedUp");
            var local = this.convertToNodeSpace(pos);
            var t = this._bmd.getPixel4B(local.x, this._bmd.getHeight() - local.y);

            //            trace(t.a);
            if (t.a > 0) {
                var e = new tx.ev.MouseTouchEvent(tx.ev.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, local);
                this._ed.dispatchEvent(e);
            }
            if (this._isOver) {
                this._isOver = false;
                var e = new tx.ev.MouseTouchEvent(tx.ev.MouseTouchEvent.MOUSE_TOUCH_OUT, local);
                this._ed.dispatchEvent(e);
            }
        };

        Bitmap.prototype.onMouseDraggedTouchMove = function (pos) {
            //            trace("onMouseDraggedTouchMove",pos.x);
            var local = this.convertToNodeSpace(pos);
            var t = this._bmd.getPixel4B(local.x, this._bmd.getHeight() - local.y);
            if (t.a > 0) {
                var e = new tx.ev.MouseTouchEvent(tx.ev.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, local);
                this._ed.dispatchEvent(e);
                if (!this._isOver) {
                    this._isOver = true;
                    var e = new tx.ev.MouseTouchEvent(tx.ev.MouseTouchEvent.MOUSE_TOUCH_OVER, local);
                    this._ed.dispatchEvent(e);
                }
            } else {
                if (this._isOver) {
                    this._isOver = false;
                    var e = new tx.ev.MouseTouchEvent(tx.ev.MouseTouchEvent.MOUSE_TOUCH_OUT, local);
                    this._ed.dispatchEvent(e);
                }
            }
        };
        return Bitmap;
    })(cc.Layer);
    tx.Bitmap = Bitmap;
})(tx || (tx = {}));
///<reference path='../ImportTs.d.ts' />
var tx;
(function (tx) {
    var BitmapData = (function () {
        function BitmapData(width, height, transparent, fillColor) {
            if (typeof transparent === "undefined") { transparent = true; }
            if (typeof fillColor === "undefined") { fillColor = 0xFFFFFFFF; }
            this._lock = false;
            this._width = width;
            this._height = height;
            this._transparent = transparent;
            this._fillColor = fillColor;

            this._temp_Canvas = document.createElement("canvas");
            this._temp_ctx = this._temp_Canvas.getContext("2d");
            this._temp_Canvas.width = this._width;
            this._temp_Canvas.height = this._height;
            this._ImgData = this._temp_ctx.createImageData(this._width, this._height);
            //TODO:默认颜色填充
        }
        BitmapData.prototype.clone = function () {
            var temp = new BitmapData(this._width, this._height, this._transparent, this._fillColor);
            temp._ImgData = this._temp_ctx.createImageData(this._width, this._height);
            for (var i = 0; i < this._ImgData.data.length; i += 4) {
                temp._ImgData.data[i] = this._ImgData.data[i];
            }
            temp.updateImageEle();
            return temp;
        };

        BitmapData.prototype.draw = function (soucre, matrix, colorTransform, blendMode, clipRect, smoothing) {
            if (typeof matrix === "undefined") { matrix = null; }
            if (typeof colorTransform === "undefined") { colorTransform = null; }
            if (typeof blendMode === "undefined") { blendMode = null; }
            if (typeof clipRect === "undefined") { clipRect = null; }
            if (typeof smoothing === "undefined") { smoothing = false; }
            var _this = this;
            cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);
            var oldParent = soucre.getParent();
            if (oldParent) {
                oldParent.removeChild(soucre);
            }

            if (clipRect == null) {
                clipRect = new cc.Rect(0, 0, this._width, this._height);
            }

            //转换全局缩放
            if (cc.EGLView.getInstance()._resolutionPolicy != cc.RESOLUTION_POLICY.UNKNOWN) {
                var designResolutionSize = cc.EGLView.getInstance().getDesignResolutionSize();
                cc.EGLView.getInstance().setFrameSize(designResolutionSize.width, designResolutionSize.height);
                cc.EGLView.getInstance()._adjustSize();
            }

            var scene = cc.Scene.create();
            scene.addChild(soucre);

            //record tranMatrix;
            if (matrix == null) {
                matrix = new tx.mh.Matrix(1, 0, 0, 1, 0, 0);
            }

            var oldTran = soucre.nodeToParentTransform();
            soucre._transform = matrix;

            scene.draw = function (ctx) {
                var color = _this._fillColor % 0x1000000;
                var alpha = _this._transparent ? ((_this._fillColor >> 24) % 0x100) : 255;
                ctx.fillStyle = color.toString(16);
                ctx.globalAlpha = alpha / 255;
                ctx.fillRect(0, 0, _this._width, -_this._height);
                ctx.globalAlpha = 1;
            };

            var tempNode = new cc.Node();
            scene.addChild(tempNode);
            tempNode.draw = function (ctx) {
                _this._ImgData = ctx.getImageData(clipRect.origin.x, cc.canvas.height - _this._height + clipRect.origin.y, clipRect.size.width, clipRect.size.height);

                //                for (var i = 0; i < this._ImgData.data.length; i += 4) {
                //                    cc.log
                //                    this._ImgData.data[i] = 255 - this._ImgData.data[i];
                //                    this._ImgData.data[i + 1] = 255 - this._ImgData.data[i + 1];
                //                    this._ImgData.data[i + 2] = 255 - this._ImgData.data[i + 2];
                //                    this._ImgData.data[i + 3] = 255;
                //                }
                //                this._temp_ctx.putImageData(this._ImgData, 0, 0);
                _this.updateImageEle();

                //recover
                soucre._transform = oldTran;
                scene.removeChild(soucre);
                if (oldParent) {
                    oldParent.addChild(soucre);
                }

                //还原全局缩放
                if (cc.EGLView.getInstance()._resolutionPolicy != cc.RESOLUTION_POLICY.UNKNOWN) {
                    cc.EGLView.getInstance().setDesignResolutionSize(designResolutionSize.width, designResolutionSize.height, cc.EGLView.getInstance()._resolutionPolicy);
                    cc.EGLView.getInstance()._adjustSize();
                }
            };
            scene.visit();
        };

        BitmapData.prototype.isInRect = function (x, y) {
            if (x >= 0 && y >= 0 && x <= this._width && y <= this._height) {
                return true;
            } else {
                return false;
            }
        };

        BitmapData.prototype.setPixel = function (x, y, color) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var c = tx.Utils.COLOR_3B(color);

                //            trace(c.r, c.g, c.b);
                this._ImgData.data[(y * this._width + x) * 4] = c.r;
                this._ImgData.data[((y * this._width + x) * 4) + 1] = c.g;
                this._ImgData.data[((y * this._width + x) * 4) + 2] = c.b;
                this._ImgData.data[((y * this._width + x) * 4) + 3] = 1;
                this.updateImageEle();
            }
        };

        BitmapData.prototype.setPixel32 = function (x, y, color) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var c = tx.Utils.COLOR_4B(color);

                //            trace(c.r, c.g, c.b, c.a);
                this._ImgData.data[(y * this._width + x) * 4] = c.r;
                this._ImgData.data[((y * this._width + x) * 4) + 1] = c.g;
                this._ImgData.data[((y * this._width + x) * 4) + 2] = c.b;
                this._ImgData.data[((y * this._width + x) * 4) + 3] = c.a;
                this.updateImageEle();
            }
        };

        BitmapData.prototype.getPixel = function (x, y) {
            return tx.Utils.C3B_TO_UINT(this.getPixel3B(x, y));
        };

        BitmapData.prototype.getPixel3B = function (x, y) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var r = this._ImgData.data[(y * this._width + x) * 4];
                var g = this._ImgData.data[((y * this._width + x) * 4) + 1];
                var b = this._ImgData.data[((y * this._width + x) * 4) + 2];
                return new cc.Color3B(r, g, b);
            } else {
                return new cc.Color3B(0, 0, 0);
            }
        };

        BitmapData.prototype.getPixel32 = function (x, y) {
            return tx.Utils.C4B_TO_UINT(this.getPixel4B(x, y));
        };

        BitmapData.prototype.getPixel4B = function (x, y) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var r = this._ImgData.data[(y * this._width + x) * 4];
                var g = this._ImgData.data[((y * this._width + x) * 4) + 1];
                var b = this._ImgData.data[((y * this._width + x) * 4) + 2];
                var a = this._ImgData.data[((y * this._width + x) * 4) + 3];
                return new cc.Color4B(r, g, b, a);
            } else {
                return new cc.Color4B(0, 0, 0, 0);
            }
        };

        BitmapData.prototype.lock = function () {
            this._lock = true;
        };

        BitmapData.prototype.unlock = function () {
            if (this._lock == true) {
                this._lock = false;
                this.updateImageEle();
            }
        };

        BitmapData.prototype._getImgData = function () {
            return this._ImgData;
        };

        BitmapData.prototype._getImageEle = function () {
            return this._temp_Canvas;
        };

        BitmapData.prototype.getData = function () {
            return this._ImgData.data;
        };

        BitmapData.prototype.setData = function (data) {
            this._ImgData.data = data;
            this.updateImageEle();
        };

        BitmapData.prototype.updateImageEle = function () {
            if (!this._lock) {
                this._temp_ctx.clearRect(0, 0, this._width, this._height);
                this._temp_ctx.putImageData(this._ImgData, 0, 0);
            }
        };

        BitmapData.prototype.getWidth = function () {
            return this._width;
        };

        BitmapData.prototype.getHeight = function () {
            return this._height;
        };
        return BitmapData;
    })();
    tx.BitmapData = BitmapData;
})(tx || (tx = {}));
var tx;
(function (tx) {
    ///<reference path='../ImportTs.d.ts' />
    (function (mh) {
        var Matrix = (function (_super) {
            __extends(Matrix, _super);
            function Matrix() {
                _super.apply(this, arguments);
            }
            return Matrix;
        })(cc.AffineTransform);
        mh.Matrix = Matrix;
    })(tx.mh || (tx.mh = {}));
    var mh = tx.mh;
})(tx || (tx = {}));
///<reference path='../ImportTs.d.ts' />
/**
* Created with JetBrains WebStorm.
* User: admin
* Date: 13-9-18
* Time: 下午2:46
* To change this template use File | Settings | File Templates.
*/
function getQualifiedClassName(ob) {
    //通过构造函数获得类名
    return ob["constructor"].name;
}

function getDefinitionByName(name, module) {
    if (typeof module === "undefined") { module = null; }
    if (module == null) {
        return eval(name + ".prototype.constructor");
    } else {
        return eval(module + "." + name + ".prototype.constructor");
    }
}

var tx;
(function (tx) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.SET_COLOR_4B_BY_UINT = function (drawingUtil, uintNumber, alpha) {
            drawingUtil.setDrawColor4B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100, alpha);
            //        var tt:number = 0x7FFF00F7;
            //        cc.log((uintNumber).toString(16));
            //        cc.log(((uintNumber>>0)%0x100).toString(16));
            //        cc.log(((uintNumber>>8)%0x100).toString(16));
            //        cc.log(((uintNumber>>16)%0x100).toString(16));
        };

        Utils.COLOR_4F = function (uintNumber, alpha) {
            if (typeof alpha === "undefined") { alpha = 1; }
            return new cc.Color4F(((uintNumber >>> 16) % 0x100) / 255, ((uintNumber >>> 8) % 0x100) / 255, ((uintNumber >>> 0) % 0x100) / 255, alpha);
        };

        Utils.COLOR_4B_Trans = function (uintNumber, colorTransform) {
            return new cc.Color4B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100, colorTransform ? ((uintNumber >>> 24) % 0x100) : 255);
        };

        Utils.COLOR_3B = function (uintNumber) {
            return new cc.Color3B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100);
        };

        Utils.COLOR_4B = function (uintNumber) {
            //            trace("aaa",uintNumber,(uintNumber >> 16));
            //                    var tt:number = 0x80FF00F7;
            //
            //            cc.log((uintNumber).toString(16));
            //            cc.log(((uintNumber>>0)%0x100).toString(16));
            //            uintNumber = tt;
            //        cc.log((uintNumber).toString());
            //        cc.log((uintNumber).toString(16));
            //        cc.log(((uintNumber>>0)%0x100).toString(16));
            //        cc.log(((uintNumber>>8)%0x100).toString(16));
            //        cc.log(((uintNumber>>16)%0x100).toString(16));
            //            cc.log(((uintNumber>>>0)%0x100).toString(16));
            //            cc.log(((uintNumber>>>8)%0x100).toString(16));
            //            cc.log(((uintNumber>>>16)%0x100).toString(16));
            //            cc.log(((uintNumber>>>24)%0x100).toString(16));
            //
            return new cc.Color4B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100, (uintNumber >>> 24) % 0x100);
        };

        Utils.C4B_TO_UINT = function (c4b) {
            return Utils.COLOR_4B_TO_UINT(c4b.r, c4b.g, c4b.b, c4b.a);
        };

        Utils.C3B_TO_UINT = function (c3b) {
            return Utils.COLOR_3B_TO_UINT(c3b.r, c3b.g, c3b.b);
        };

        Utils.COLOR_4B_TO_UINT = function (r, g, b, a) {
            return a * 0x1000000 + r * 0x10000 + g * 0x100 + b;
        };

        Utils.COLOR_3B_TO_UINT = function (r, g, b) {
            return r * 0x10000 + g * 0x100 + b;
        };

        Utils.CheckPosInMenuRect = function (menuItem, pos) {
            var local = menuItem.convertToNodeSpace(pos);
            var r = menuItem.rect();
            r.origin.x = 0;
            r.origin.y = 0;
            return cc.rectContainsPoint(r, local);
        };

        Utils.FadeOutAndRemoveFromParent = function (sprite, sec) {
            var removeFromParentAndCleanup = function (nodeExecutingAction, data) {
                nodeExecutingAction.removeFromParent(data);
            };
            var returnFunction = function () {
                return removeFromParentAndCleanup;
            };

            var action = cc.Sequence.create(cc.FadeOut.create(sec), cc.CallFunc.create(returnFunction(), sprite, true));
            sprite.runAction(action);

            var children = sprite.getChildren();
            for (var i = 0; i < children.length; i++) {
                Utils.AllFadeOut(children[i], sec);
            }
        };

        Utils.AllFadeIn = function (node, time) {
            if (node["setOpacity"] != null) {
                var action = cc.FadeIn.create(time);
                node.runAction(action);
            }
            var children = node.getChildren();
            for (var i = 0; i < children.length; i++) {
                Utils.AllFadeIn(children[i], time);
            }
        };

        Utils.AllFadeOut = function (node, time) {
            if (node["setOpacity"] != null) {
                var action = cc.FadeOut.create(time);
                node.runAction(action);
            }
            var children = node.getChildren();
            for (var i = 0; i < children.length; i++) {
                Utils.AllFadeOut(children[i], time);
            }
        };

        Utils.MaxPoint = function (p1, p2) {
            var tempPoint = new cc.Point(0, 0);
            tempPoint.x = p1.x > p2.x ? p1.x : p2.x;
            tempPoint.y = p1.y > p2.y ? p1.y : p2.y;
            return tempPoint;
        };

        Utils.MinPoint = function (p1, p2) {
            var tempPoint = new cc.Point(0, 0);
            tempPoint.x = p1.x < p2.x ? p1.x : p2.x;
            tempPoint.y = p1.y < p2.y ? p1.y : p2.y;
            return tempPoint;
        };

        Utils.GetRectScale = function (soucreWH, targetWH) {
            var xScale = targetWH.x / soucreWH.x;
            var yScale = targetWH.y / soucreWH.y;
            return xScale < yScale ? xScale : yScale;
        };

        Utils.GetRealPixBitmapData = function (bmd) {
            var tempBmd;
            var data = bmd.getData();
            var width = bmd.getWidth();
            var height = bmd.getHeight();
            var minPoint = new cc.Point(width, height);
            var maxPoint = new cc.Point(0, 0);
            for (var i = 0; i < width; i++) {
                for (var j = 0; j < height; j++) {
                    var a = data[((j * width + i) * 4) + 3];
                    if (a != 0) {
                        maxPoint = tx.Utils.MaxPoint(maxPoint, new cc.Point(i, j));
                        minPoint = tx.Utils.MinPoint(minPoint, new cc.Point(i, j));
                    }
                }
            }

            var newWidth = maxPoint.x - minPoint.x;
            var newHeight = maxPoint.y - minPoint.y;

            tempBmd = new tx.BitmapData(newWidth, newHeight, true, 0);
            var tempData = tempBmd.getData();
            for (var i = 0; i < newWidth; i++) {
                for (var j = 0; j < newHeight; j++) {
                    tempData[((j * newWidth + i) * 4)] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4)];
                    tempData[((j * newWidth + i) * 4) + 1] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4) + 1];
                    tempData[((j * newWidth + i) * 4) + 2] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4) + 2];
                    tempData[((j * newWidth + i) * 4) + 3] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4) + 3];
                }
            }
            tempBmd.setData(tempData);
            return tempBmd;
        };
        return Utils;
    })();
    tx.Utils = Utils;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var Attach = (function () {
        function Attach() {
        }
        /**
        * 从库中取得 Sprite
        */
        Attach.getSprite = function (s, plistName) {
            if (typeof plistName === "undefined") { plistName = null; }
            if (plistName != null) {
                cc.SpriteFrameCache.getInstance().addSpriteFrames(plistName);
            }
            return cc.Sprite.createWithSpriteFrameName(s);
        };

        /**
        * 从库中取得 BitmapData
        * @param s BitmapData在库中绑定的类名
        * @param repeatedUse_NoChange 这个BitmapData被多次使用且不会被修改时请打开此选项,这有助于节约内存资源,请不要dispose该对象,清理请使用clearBitmapDataCache()
        */
        Attach.getBitmapData = function (s, repeatedUse_NoChange, plistName) {
            if (typeof repeatedUse_NoChange === "undefined") { repeatedUse_NoChange = false; }
            if (typeof plistName === "undefined") { plistName = null; }
            if (repeatedUse_NoChange) {
                if (!Attach.bitMapDataArray) {
                    Attach.bitMapDataArray = {};
                }
                if (Attach.bitMapDataArray[s] != null) {
                    //如果无效的BITMAP DATA(已被dispose),则删除
                    //						if((Attach.bitMapDataArray[i][1] as BitmapData).width == 0 && (Attach.bitMapDataArray[i][1] as BitmapData).height == 0)
                    //						{
                    //							Attach.bitMapDataArray.splice(i, 1);
                    //							break;
                    //						}
                    //						else
                    //						{
                    //找到了返回
                    //                    trace("yes")
                    return Attach.bitMapDataArray[s];
                    //						}
                }
                //找不到就创建新的
            }

            // var temp:Class;
            if (plistName != null) {
                cc.SpriteFrameCache.getInstance().addSpriteFrames(plistName);
            }
            var tempMc = cc.Sprite.createWithSpriteFrameName(s);
            tempMc.setAnchorPoint(cc.p(0, 1));

            //拍图片
            var rect = tempMc.getBoundingBox();
            var returnBmd = new tx.BitmapData(rect.width, rect.height, true, 0);
            returnBmd.draw(tempMc);

            //        var returnObj : BitmapData = new temp(null, null);
            if (repeatedUse_NoChange) {
                Attach.bitMapDataArray[s] = returnBmd;
            }
            return returnBmd;
        };

        /**
        * 不能在
        */
        Attach.clearBitmapDataCache = function () {
            for (var i = 0; i < Attach.bitMapDataArray.length; i++) {
                Attach.bitMapDataArray[i][1].dispose();
            }
            Attach.bitMapDataArray = {};
        };
        Attach.bitMapDataArray = {};
        return Attach;
    })();
    tx.Attach = Attach;
})(tx || (tx = {}));
