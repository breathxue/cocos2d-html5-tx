///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var mVector = (function () {
        function mVector(px, py) {
            if (typeof px === "undefined") { px = 0; }
            if (typeof py === "undefined") { py = 0; }
            this.x = px;
            this.y = py;
        }
        /**
        * 重新设定向量值
        * @param px x轴方向值
        * @param py y轴方向值
        */
        mVector.prototype.setTo = function (px, py) {
            this.x = px;
            this.y = py;
        };

        /**
        * 拷贝传入参数的向量值,重新设定向量值.
        * @param v 被拷贝的原始向量值
        */
        mVector.prototype.copyFrom = function (v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        };

        /**
        * toString函数
        */
        mVector.prototype.toString = function () {
            var rx = Math.round(this.x * 1000) / 1000;
            var ry = Math.round(this.y * 1000) / 1000;
            return "[" + rx + "," + ry + "]";
        };

        /**
        * 获得当前向量的拷贝
        */
        mVector.prototype.clone = function () {
            return new mVector(this.x, this.y);
        };

        /**
        * 向量加 +
        * @param v 向量,加数
        * @return 返回被加后的新的向量
        */
        mVector.prototype.plus = function (v) {
            return new mVector(this.x + v.x, this.y + v.y);
        };

        /**
        * 向量加等于 +=
        * @param v 向量,加数
        * @return 返回被加后的向量
        */
        mVector.prototype.plusEquals = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };

        /**
        * 向量减 -
        * @param v 向量,减数
        * @return 返回被加后的新的向量
        */
        mVector.prototype.minus = function (v) {
            return new mVector(this.x - v.x, this.y - v.y);
        };

        /**
        * 向量减等于 -=
        * @param v 向量,减数
        * @return 返回被加后的向量
        */
        mVector.prototype.minusEquals = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };

        /**
        * 向量非 !
        * @return 返回和原始向量相反的新向量
        */
        mVector.prototype.negate = function () {
            return new mVector(-this.x, -this.y);
        };

        /**
        * 向量非等于 !=
        * @return 返回被相反计算后的向量
        */
        mVector.prototype.negateEquals = function () {
            this.x = -this.x;
            this.y = -this.y;
        };

        /**
        * 向量乘 *
        * @param s 数字,乘数
        * @return 返回被加后的新向量
        */
        mVector.prototype.mult = function (s) {
            return new mVector(this.x * s, this.y * s);
        };

        /**
        * 向量乘等于 *=
        * @param s 数字,乘数
        * @return 返回被加后的向量
        */
        mVector.prototype.multEquals = function (s) {
            this.x *= s;
            this.y *= s;
            return this;
        };

        /**
        * 向量旋转
        * @param ang 数字,角度
        * @return 返回被旋转后的新向量
        */
        mVector.prototype.rotateAngle = function (angle) {
            var cos = tx.TF_Class.cosD(angle);
            var sin = tx.TF_Class.sinD(angle);
            var result = new mVector(this.x * cos - this.y * sin, this.y * cos + this.x * sin);
            return result;
        };

        /**
        * 向量旋转等于
        * @param ang 数字,角度
        * @return 返回被旋转后的向量
        */
        mVector.prototype.rotateAngleEquals = function (angle) {
            return this.copyFrom(this.rotateAngle(angle));
        };

        /**
        * 向量围绕指定点旋转
        * @param ang 数字,角度
        * @param targetPoint 目标点
        * @return 返回被旋转后的新向量
        */
        mVector.prototype.rotateAngleForTarget = function (angle, targetPoint) {
            var tempVector = this.minus(targetPoint);
            var cos = tx.TF_Class.cosD(angle);
            var sin = tx.TF_Class.sinD(angle);
            var tempResult = new mVector(tempVector.x * cos - tempVector.y * sin, tempVector.y * cos + tempVector.x * sin);
            var result = tempResult.plus(targetPoint);

            return result;
        };

        /**
        * 向量围绕指定点旋转等于
        * @param ang 数字,角度
        * @param targetPoint 目标点
        * @return 返回被旋转后的新向量
        */
        mVector.prototype.rotateAngleForTargetEquals = function (angle, targetPoint) {
            return this.copyFrom(this.rotateAngleForTarget(angle, targetPoint));
        };

        /**
        * 向量旋转
        * @param radian 数字,弧度
        * @return 返回被旋转后的新向量
        */
        mVector.prototype.rotateRadian = function (radian) {
            var cos = Math.cos(radian);
            var sin = Math.sin(radian);
            var result = new mVector(this.x * cos - this.y * sin, this.y * cos + this.x * sin);
            return result;
        };

        /**
        * 向量旋转等于
        * @param radian 数字,弧度
        * @return 返回被旋转后的向量
        */
        mVector.prototype.rotateRadianEquals = function (radian) {
            return this.copyFrom(this.rotateRadian(radian));
        };

        /**
        * 向量围绕指定点旋转
        * @param radian 数字,弧度
        * @param targetPoint 目标点
        * @return 返回被旋转后的新向量
        */
        mVector.prototype.rotateRadianForTarget = function (radian, targetPoint) {
            var tempVector = this.minus(targetPoint);
            var cos = Math.cos(radian);
            var sin = Math.sin(radian);
            var tempResult = new mVector(tempVector.x * cos - tempVector.y * sin, tempVector.y * cos + tempVector.x * sin);
            var result = tempResult.plus(targetPoint);

            return result;
        };

        /**
        * 向量围绕指定点旋转等于
        * @param radian 数字,弧度
        * @param targetPoint 目标点
        * @return 返回被旋转后的新向量
        */
        mVector.prototype.rotateRadianForTargetEquals = function (radian, targetPoint) {
            return this.copyFrom(this.rotateRadianForTarget(radian, targetPoint));
        };

        /**
        * 向量点乘 .*
        * @param v 向量,乘数
        * @return 点乘数
        */
        mVector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };

        /**
        * 向量点差 .x
        * @param v 向量,x数
        * @return 点x数
        */
        mVector.prototype.cross = function (v) {
            return this.x * v.y - this.y * v.x;
        };

        mVector.prototype.times = function (v) {
            return new mVector(this.x * v, this.y * v);
        };

        mVector.prototype.div = function (s) {
            if (s == 0) {
                s = 0.0001;
            }

            return new mVector(this.x / s, this.y / s);
        };

        mVector.prototype.divEquals = function (s) {
            if (s == 0) {
                s = 0.0001;
            }
            this.x /= s;
            this.y /= s;
            return this;
        };

        /**
        * 获得2点之间距离
        */
        mVector.prototype.distance = function (v) {
            var delta = this.minus(v);
            return delta.getLength();
        };

        /**
        * 规格化向量,设置向量长度为1,不改变原向量
        */
        mVector.prototype.normalize = function () {
            var m = this.getLength();
            if (m == 0) {
                m = 0.0001;
            }
            return this.mult(1 / m);
        };

        /**
        * 比较两向量的值是否相同
        */
        mVector.prototype.compare = function (v) {
            if (this.x == v.x && this.y == v.y) {
                return true;
            }
            return false;
        };

        /**
        * 获得向量法线
        */
        mVector.prototype.getNormal = function () {
            return new mVector(-this.y, this.x);
        };

        /**
        * 两向量是否互相垂直
        */
        mVector.prototype.isNormalTo = function (v) {
            return (this.dot(v) == 0);
        };

        /**
        * 获得2向量的角度差
        */
        mVector.prototype.angleBetween = function (v) {
            var dp = this.dot(v);
            var cosAngle = dp / (this.getLength() * v.getLength());
            return tx.TF_Class.acosD(cosAngle);
        };

        /**
        * 两向量夹角,弧度
        */
        mVector.prototype.radianBetween = function (v) {
            var cos = this.dot(v) / (this.getLength() * v.getLength());
            return Math.acos(cos);
        };

        /**
        * 获得向量长度
        */
        mVector.prototype.getLength = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };

        mVector.prototype.setLength = function (len) {
            var r = this.getLength();
            if (r) {
                this.mult(len / r);
            } else {
                this.x = len;
            }
        };

        /**
        * 设定向量的角度
        */
        mVector.prototype.setAngle = function (ang) {
            var r = this.getLength();
            this.x = r * tx.TF_Class.cosD(ang);
            this.y = r * tx.TF_Class.sinD(ang);
        };

        mVector.prototype.getAngle = function () {
            return tx.TF_Class.atan2D(this.y, this.x);
        };
        mVector.PI_OVER_ONE_EIGHTY = Math.PI / 180;
        return mVector;
    })();
    tx.mVector = mVector;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var TF_Class = (function () {
        function TF_Class() {
        }
        /**
        * 正弦函数
        */
        TF_Class.sinD = function (angle) {
            return Math.sin((angle * Math.PI / 180));
        };

        /**
        * 余弦函数
        */
        TF_Class.cosD = function (angle) {
            return Math.cos(angle * Math.PI / 180);
        };

        /**
        * 正切函数
        */
        TF_Class.tanD = function (angle) {
            return Math.tan(angle * Math.PI / 180);
        };

        /**
        * 反正弦函数
        */
        TF_Class.asinD = function (ratio) {
            return Math.asin(ratio) * (180 / Math.PI);
        };

        /**
        * 反余弦函数
        */
        TF_Class.acosD = function (ratio) {
            return Math.acos(ratio) * (180 / Math.PI);
        };

        /**
        * 反正切函数
        */
        TF_Class.atanD = function (ratio) {
            return Math.atan(ratio) * (180 / Math.PI);
        };

        /**
        * 两倍反正切函数
        */
        TF_Class.atan2D = function (y, x) {
            return Math.atan2(y, x) * (180 / Math.PI);
        };

        /**
        * 2点之前距离
        */
        TF_Class.distance = function (x1, y1, x2, y2) {
            var dx = x2 - x1;
            var dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        };

        /**
        * 2点连线的角度
        */
        TF_Class.angleOfLine = function (x1, y1, x2, y2) {
            return TF_Class.atan2D(y2 - y1, x2 - x1);
        };

        /**
        * 角度转弧度
        */
        TF_Class.degreesToRadians = function (angle) {
            return angle * (Math.PI / 180);
        };

        /**
        * 弧度转角度
        */
        TF_Class.radiansToDegrees = function (radian) {
            return radian * (180 / Math.PI);
        };

        /**
        * 角度值归正函数,归正传入参数的角度值,返回0度至360度的角度值.
        */
        TF_Class.fixAngle = function (angle) {
            return ((angle %= 360) < 0) ? angle + 360 : angle;
        };

        /**
        * 计算向量的角度和长度
        * @return 返回object,object.r为长度,object.t为角度
        */
        TF_Class.cartesianToPolar = function (p) {
            var radius = Math.sqrt(p.x * p.x + p.y + p.y);
            var theta = TF_Class.atan2D(p.y, p.x);
            return { r: radius, t: theta };
        };

        /**
        * 角度值归正函数,归正传入参数的角度值,返回-180度至180度的角度值.
        */
        TF_Class.FormatAngle = function (angle) {
            angle = angle % 360;
            if (angle > 180) {
                angle = angle - 360;
            }
            if (angle < -180) {
                angle = angle + 360;
            }
            return angle;
        };

        /**
        * 角度值归正函数,归正传入参数的角度值,返回-90度至90度的角度值.
        */
        TF_Class.FormatAngle90 = function (angle) {
            angle = angle % 180;
            if (angle > 90) {
                angle = 180 - angle;
            }
            if (angle < -90) {
                angle = angle + 180;
            }
            return angle;
        };
        return TF_Class;
    })();
    tx.TF_Class = TF_Class;
})(tx || (tx = {}));
///<reference path='ImportTS.d.ts' />
///<reference path='../ImportTS.d.ts' />
function trace() {
    var args = [];
    for (var _i = 0; _i < (arguments.length - 0); _i++) {
        args[_i] = arguments[_i + 0];
    }
    var out = "";
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (arg instanceof cc.Point) {
            out += "(" + arg.x + "," + arg.y + ")" + " ";
        } else {
            out += arg + " ";
        }
    }
    console.log(out);
    //    cc.log(out);
}

function Trace() {
    var args = [];
    for (var _i = 0; _i < (arguments.length - 0); _i++) {
        args[_i] = arguments[_i + 0];
    }
    trace(args);
}
///<reference path='../ImportTS.d.ts' />
/**
* Created with JetBrains WebStorm.
* User: admin
* Date: 13-9-27
* Time: 下午3:47
* To change this template use File | Settings | File Templates.
*/
var tx;
(function (tx) {
    var EventDispatcher = (function () {
        function EventDispatcher(target) {
            this._eventHandlers = {};
            this._target = target;
            if (this._target == null) {
                this._target = this;
            }
        }
        EventDispatcher.prototype.destroy = function () {
            this._target = null;
            this._eventHandlers = null;
        };

        // maintain a list of listeners
        EventDispatcher.prototype.addEventListener = function (eventType, theHandler, listener) {
            if (typeof listener === "undefined") { listener = null; }
            this._eventHandlers[eventType] = this._eventHandlers[eventType] || [];
            this._eventHandlers[eventType].push([theHandler, listener]);
        };

        // remove a listener
        EventDispatcher.prototype.removeEventListener = function (eventType, theHandler) {
            this._eventHandlers[eventType] = this._eventHandlers[eventType] || [];
            var theHandlers = this._eventHandlers[eventType];
            if (theHandlers) {
                for (var i = 0; i < theHandlers.length; i += 1) {
                    if (theHandlers[i][0] == theHandler) {
                        theHandlers.splice(i, 1);
                    }
                }
            }
        };

        EventDispatcher.prototype.hasEventListener = function (eventType) {
            this._eventHandlers[eventType] = this._eventHandlers[eventType] || [];
            var theHandlers = this._eventHandlers[eventType];

            return (theHandlers != null && theHandlers.length > 0);
            //            if (theHandlers!=null && theHandlers.length > 0) {
            //                return true;
            //            }
            //            else {
            //                return false;
            //            }
        };

        // remove all listeners
        EventDispatcher.prototype.removeAllListeners = function (eventType) {
            this._eventHandlers[eventType] = [];
        };

        // dispatch event to all listeners
        EventDispatcher.prototype.dispatchEvent = function (theEvent) {
            theEvent.target = this._target;
            var theHandlers = this._eventHandlers[theEvent.type];
            if (theHandlers) {
                for (var i = 0; i < theHandlers.length; i += 1) {
                    theEvent.listener = theHandlers[i][1];
                    this.dispatchEventToHander(theEvent, theHandlers[i][0], theHandlers[i][1]);
                }
            }
        };

        // send event to a handler
        EventDispatcher.prototype.dispatchEventToHander = function (theEvent, theHandler, listener) {
            if (typeof listener === "undefined") { listener = null; }
            listener = listener || this;
            theHandler.call(listener, theEvent);
        };
        return EventDispatcher;
    })();
    tx.EventDispatcher = EventDispatcher;
})(tx || (tx = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
///<reference path='../ImportTS.d.ts' />
/**
* Created with JetBrains WebStorm.
* User: admin
* Date: 13-9-27
* Time: 下午3:47
* To change this template use File | Settings | File Templates.
*/
var tx;
(function (tx) {
    var Timer = (function (_super) {
        __extends(Timer, _super);
        function Timer(s, repeatCount) {
            if (typeof repeatCount === "undefined") { repeatCount = 0; }
            var _this = this;
            _super.call(this);
            this._isRunning = false;
            this._repeatCount = 0;
            this._count = 0;
            this._isRunning = true;
            this._repeatCount = repeatCount;
            this._id = setInterval(function () {
                _this.run();
            }, s);
        }
        Timer.prototype.destroy = function () {
            clearInterval(this._id);
            _super.prototype.destroy.call(this);
        };

        Timer.prototype.run = function () {
            //            trace("this._isRunning", this._isRunning);
            if (this._isRunning) {
                this.dispatchEvent(new tx.Event(Timer.TIMER));
                this._count++;
                if (this._count >= this._repeatCount) {
                    clearInterval(this._id);
                    this.dispatchEvent(new tx.Event(Timer.TIMER_COMPLETE));
                }
            }
        };

        Timer.prototype.start = function () {
            this._isRunning = true;
        };

        Timer.prototype.stop = function () {
            this._isRunning = false;
        };

        Timer.prototype.isRunning = function () {
            return this._isRunning;
        };
        Timer.TIMER = "TIMER";
        Timer.TIMER_COMPLETE = "TIMER_COMPLETE";
        return Timer;
    })(tx.EventDispatcher);
    tx.Timer = Timer;
    tx._enter;

    function enterFrame() {
        if (tx._enter == null) {
            tx._enter = new Timer(cc.Director.getInstance().getAnimationInterval() * 1000, Number.MAX_VALUE);
            tx._enter.run = function () {
                if (tx._enter.isRunning()) {
                    tx._enter.dispatchEvent(new tx.Event(tx.Event.ENTER_FRAME));
                }
            };
            tx._enter.start();
        }
        return tx._enter;
    }
    tx.enterFrame = enterFrame;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
/**
* Created with JetBrains WebStorm.
* User: admin
* Date: 13-9-27
* Time: 下午3:47
* To change this template use File | Settings | File Templates.
*/
var tx;
(function (tx) {
    var Event = (function () {
        function Event(type) {
            this.type = type;
        }
        Event.prototype.clone = function () {
            var t = new tx.Event(this.type);
            t.target = this.target;
            t.listener = this.listener;
            return t;
        };

        Event.prototype.destroy = function () {
            this.target = null;
            this.listener = null;
        };
        Event.ENTER_FRAME = "ENTER_FRAME";
        Event.COMPLETE = "COMPLETE";
        Event.CHANGE = "CHANGE";
        return Event;
    })();
    tx.Event = Event;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var MouseTouchEvent = (function (_super) {
        __extends(MouseTouchEvent, _super);
        function MouseTouchEvent(type, pos, worldPos) {
            _super.call(this, type);
            this.pos = pos;
            this.worldPos = worldPos;
        }
        MouseTouchEvent.prototype.destroy = function () {
            this.pos = null;
            this.worldPos = null;
            _super.prototype.destroy.call(this);
        };
        MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN = "MOUSE_DOWN_TOUCH_BEGAN";
        MouseTouchEvent.MOUSE_UP_TOUCH_ENDED = "MOUSE_UP_TOUCH_ENDED";
        MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE = "MOUSE_DRAGGED_TOUCH_MOVE";
        MouseTouchEvent.MOUSE_TOUCH_OVER = "MOUSE_TOUCH_OVER";
        MouseTouchEvent.MOUSE_TOUCH_OUT = "MOUSE_TOUCH_OUT";
        return MouseTouchEvent;
    })(tx.Event);
    tx.MouseTouchEvent = MouseTouchEvent;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var DisplayObject = (function () {
        function DisplayObject() {
        }
        DisplayObject.prototype.destroy = function () {
        };
        DisplayObject.DisplayObjectCreateNum = 0;
        return DisplayObject;
    })();
    tx.DisplayObject = DisplayObject;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    function bubblingRunFunction(mc, funString, parm) {
        var p = mc.getParent();
        if (p != null) {
            if (p[funString] != null) {
                p[funString].apply(p, parm);
            }
            tx.bubblingRunFunction(p, funString, parm);
        }
    }
    tx.bubblingRunFunction = bubblingRunFunction;

    function recursionRunFunction(node, funString, parm) {
        var children = node.getChildren();
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child[funString] != null) {
                child[funString].apply(child, parm);
            }
            tx.recursionRunFunction(child, funString, parm);
        }
    }
    tx.recursionRunFunction = recursionRunFunction;

    function interactiveObjectCreate(mc, listerOb) {
        if (typeof listerOb === "undefined") { listerOb = null; }
        var t1 = mc;
        var t2 = listerOb;
        var same = false;
        if (t1 == t2) {
            same = true;
        }

        //        if ('mouse' in sys.capabilities) {
        //            mc.setMouseEnabled(false);
        //        } else {
        //            cc.log("MOUSE Not supported");
        //        }
        //
        //        if ('touches' in sys.capabilities) {
        //            // listerOb is the default behavior. No need to set it explicitly.
        mc.setTouchMode(cc.TOUCH_ALL_AT_ONCE);

        ////            mc.setTouchMode(cc.TOUCH_ONE_BY_ONE);
        mc.setTouchEnabled(true);

        //        } else {
        //            cc.log("TOUCHES not supported");
        //        }
        //重写的回调函数,记录上一次的回调函数
        var tempFunctionBegan = mc.onTouchesBegan;
        mc.onTouchesBegan = function (touches, event) {
            if (touches.length > 0) {
                if (!same) {
                    listerOb.onTouchBegan(touches[0], event);
                }
                listerOb.onMouseDownTouchBegan(touches[0].getLocation());
            }
            if (!same) {
                listerOb.onTouchesBegan(touches, event);
            }
            tempFunctionBegan(touches, event);
            return true;
        };
        mc.onTouchesBegan["lastCallBack"] = tempFunctionBegan;

        var tempFunctionEnded = mc.onTouchesEnded;
        mc.onTouchesEnded = function (touches, event) {
            if (touches.length > 0) {
                if (!same) {
                    listerOb.onTouchEnded(touches[0], event);
                }
                listerOb.onMouseTouchEndedUp(touches[0].getLocation());
            }
            if (!same) {
                listerOb.onTouchesEnded(touches, event);
            }
            tempFunctionEnded(touches, event);
            return true;
        };
        mc.onTouchesEnded["lastCallBack"] = tempFunctionEnded;

        var tempFunctionTouchesMoved = mc.onTouchesMoved;
        mc.onTouchesMoved = function (touches, event) {
            //            trace("INNNNNNNNNNNNNNNNNNN onTouchesMoved");
            //            cc.log("onTouchesMoved");
            if (touches.length > 0) {
                if (!same) {
                    listerOb.onTouchMoved(touches[0], event);
                }
                listerOb.onMouseDraggedTouchMove(touches[0].getLocation());
            }
            if (!same) {
                listerOb.onTouchesMoved(touches, event);
            }
            tempFunctionTouchesMoved(touches, event);
            return true;
        };
        mc.onTouchesMoved["lastCallBack"] = tempFunctionTouchesMoved;

        var tempFunctionTouchBegan = mc.onTouchBegan;
        mc.onTouchBegan = function (touch, event) {
            //            trace("INNNNNNNNNNNNNNNNNNN onTouchBegan");
            if (!same) {
                listerOb.onTouchBegan(touch, event);
            }
            listerOb.onMouseDownTouchBegan(touch.getLocation());
            tempFunctionTouchBegan(touch, event);

            //            tx.bubblingRunFunction(mc,"onTouchBegan",arguments);
            tx.recursionRunFunction(mc, "onTouchBegan", arguments);
            return true;
        };
        mc.onTouchBegan["lastCallBack"] = tempFunctionTouchBegan;

        var tempFunctionTouchEnded = mc.onTouchEnded;
        mc.onTouchEnded = function (touch, event) {
            //            trace("INNNNNNNNNNNNNNNNNNN onTouchEnded");
            if (!same) {
                listerOb.onTouchEnded(touch, event);
            }
            listerOb.onMouseTouchEndedUp(touch.getLocation());
            tempFunctionTouchEnded(touch, event);

            //            tx.bubblingRunFunction(mc,"onTouchEnded",arguments);
            tx.recursionRunFunction(mc, "onTouchEnded", arguments);
            return true;
        };
        mc.onTouchEnded["lastCallBack"] = tempFunctionTouchEnded;

        var tempFunctionTouchMoved = mc.onTouchMoved;
        mc.onTouchMoved = function (touch, event) {
            //            trace("INNNNNNNNNNNNNNNNNNN onTouchMoved");
            if (!same) {
                listerOb.onTouchMoved(touch, event);
            }
            listerOb.onMouseDraggedTouchMove(touch.getLocation());
            tempFunctionTouchMoved(touch, event);

            //            tx.bubblingRunFunction(mc,"onTouchMoved",arguments);
            tx.recursionRunFunction(mc, "onTouchMoved", arguments);
            return true;
        };
        mc.onTouchMoved["lastCallBack"] = tempFunctionTouchMoved;

        var tempFunctionMouseDown = mc.onMouseDown;
        mc.onMouseDown = function (event) {
            if (!same) {
                listerOb.onMouseDown(event);
            }
            listerOb.onMouseDownTouchBegan(event.getLocation());
            tempFunctionMouseDown(event);
            return true;
        };
        mc.onMouseDown["lastCallBack"] = tempFunctionMouseDown;

        var tempFunctionMouseUp = mc.onMouseUp;
        mc.onMouseUp = function (event) {
            if (!same) {
                listerOb.onMouseUp(event);
            }
            listerOb.onMouseTouchEndedUp(event.getLocation());
            tempFunctionMouseUp(event);
            return true;
        };
        mc.onMouseUp["lastCallBack"] = tempFunctionMouseUp;

        var tempFunctionMouseDragged = mc.onMouseDragged;
        mc.onMouseDragged = function (event) {
            if (!same) {
                listerOb.onMouseDragged(event);
            }
            listerOb.onMouseDraggedTouchMove(event.getLocation());
            tempFunctionMouseDragged(event);
            return true;
        };
        mc.onMouseDragged["lastCallBack"] = tempFunctionMouseDragged;
    }
    tx.interactiveObjectCreate = interactiveObjectCreate;

    function interactiveObjectRemove(mc) {
        if (mc instanceof cc.Layer) {
            mc.onTouchesEnded = mc.onTouchesEnded["lastCallBack"];
            mc.onTouchesBegan = mc.onTouchesBegan["lastCallBack"];
            mc.onTouchesMoved = mc.onTouchesMoved["lastCallBack"];

            mc.onTouchBegan = mc.onTouchBegan["lastCallBack"];
            mc.onTouchEnded = mc.onTouchEnded["lastCallBack"];
            mc.onTouchMoved = mc.onTouchMoved["lastCallBack"];

            mc.onMouseDown = mc.onMouseDown["lastCallBack"];
            mc.onMouseUp = mc.onMouseUp["lastCallBack"];
            mc.onMouseDragged = mc.onMouseDragged["lastCallBack"];
        }
    }
    tx.interactiveObjectRemove = interactiveObjectRemove;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var InteractiveNodeRGBA = (function (_super) {
        __extends(InteractiveNodeRGBA, _super);
        function InteractiveNodeRGBA() {
            _super.call(this);
            this._name = typeof (this) + tx.DisplayObject.DisplayObjectCreateNum++;
            this._mouseEnable = false;
            this._ed = new tx.EventDispatcher(this);
            this._touchLayer = cc.Layer.create();
            this.addChild(this._touchLayer);
        }
        InteractiveNodeRGBA.prototype.destroy = function () {
            this.removeChild(this._touchLayer);
            this._touchLayer = null;
            this._ed.destroy();
            this._ed = null;
        };

        InteractiveNodeRGBA.prototype.setMouseTouchEnabled = function (b) {
            if (this._mouseEnable != b) {
                this._mouseEnable = b;
                if (b) {
                    tx.interactiveObjectCreate(this._touchLayer, this);
                } else {
                    tx.interactiveObjectRemove(this._touchLayer);
                }
            }
        };

        InteractiveNodeRGBA.prototype.getMouseTouchEnabled = function () {
            return this._mouseEnable;
        };

        InteractiveNodeRGBA.prototype.getTouchLayer = function () {
            return this._touchLayer;
        };

        InteractiveNodeRGBA.prototype.getWidth = function () {
            return this.getBoundingBox().width;
        };

        InteractiveNodeRGBA.prototype.getHeight = function () {
            return this.getBoundingBox().height;
        };

        InteractiveNodeRGBA.prototype.setWidth = function (v) {
            this.setScaleX(v / this.getContentSize().width);
        };

        InteractiveNodeRGBA.prototype.setHeight = function (v) {
            this.setScaleY(v / this.getContentSize().height);
        };

        InteractiveNodeRGBA.prototype.getMc = function () {
            return this;
        };

        InteractiveNodeRGBA.prototype.setName = function (v) {
            this._name = name;
        };

        InteractiveNodeRGBA.prototype.getName = function () {
            return this._name;
        };

        InteractiveNodeRGBA.prototype.addEventListener = function (eventType, theHandler, listener) {
            if (typeof listener === "undefined") { listener = null; }
            this._ed.addEventListener(eventType, theHandler, listener);
        };

        // remove a listener
        InteractiveNodeRGBA.prototype.removeEventListener = function (eventType, theHandler) {
            this._ed.removeEventListener(eventType, theHandler);
        };

        // remove all listeners
        InteractiveNodeRGBA.prototype.removeAllListeners = function (eventType) {
            this._ed.removeAllListeners(eventType);
        };

        InteractiveNodeRGBA.prototype.hasEventListener = function (eventType) {
            return this._ed.hasEventListener(eventType);
        };

        // dispatch event to all listeners
        InteractiveNodeRGBA.prototype.dispatchEvent = function (theEvent) {
            this._ed.dispatchEvent(theEvent);
        };

        // send event to a handler
        InteractiveNodeRGBA.prototype.dispatchEventToHander = function (theEvent, theHandler) {
            this._ed.dispatchEventToHander(theEvent, theHandler);
        };

        InteractiveNodeRGBA.prototype.onMouseDown = function (event) {
        };

        InteractiveNodeRGBA.prototype.onMouseDragged = function (event) {
        };

        InteractiveNodeRGBA.prototype.onMouseUp = function (event) {
        };

        InteractiveNodeRGBA.prototype.onTouchBegan = function (touch, event) {
        };

        InteractiveNodeRGBA.prototype.onTouchMoved = function (touch, event) {
        };

        InteractiveNodeRGBA.prototype.onTouchEnded = function (touch, event) {
        };

        InteractiveNodeRGBA.prototype.onTouchesBegan = function (touch, event) {
        };

        InteractiveNodeRGBA.prototype.onTouchesMoved = function (touch, event) {
        };

        InteractiveNodeRGBA.prototype.onTouchesEnded = function (touch, event) {
        };

        InteractiveNodeRGBA.prototype.onMouseDownTouchBegan = function (pos) {
        };

        InteractiveNodeRGBA.prototype.onMouseTouchEndedUp = function (pos) {
        };

        InteractiveNodeRGBA.prototype.onMouseDraggedTouchMove = function (pos) {
        };
        return InteractiveNodeRGBA;
    })(cc.NodeRGBA);
    tx.InteractiveNodeRGBA = InteractiveNodeRGBA;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var InteractiveLayer = (function (_super) {
        __extends(InteractiveLayer, _super);
        function InteractiveLayer() {
            _super.call(this);
            this._name = typeof (this) + tx.DisplayObject.DisplayObjectCreateNum++;
            this._mouseEnable = false;
            this._ed = new tx.EventDispatcher(this);
            this.setMouseTouchEnabled(true);
        }
        InteractiveLayer.prototype.destroy = function () {
            this._ed.destroy();
            this._ed = null;
        };

        InteractiveLayer.prototype.setMouseTouchEnabled = function (b) {
            if (this._mouseEnable != b) {
                this._mouseEnable = b;
                if (b) {
                    tx.interactiveObjectCreate(this, this);
                } else {
                    tx.interactiveObjectRemove(this);
                }
            }
        };

        InteractiveLayer.prototype.getWidth = function () {
            return this.getBoundingBox().width;
        };

        InteractiveLayer.prototype.getHeight = function () {
            return this.getBoundingBox().height;
        };

        InteractiveLayer.prototype.setWidth = function (v) {
            this.setScaleX(v / this.getContentSize().width);
        };

        InteractiveLayer.prototype.setHeight = function (v) {
            this.setScaleY(v / this.getContentSize().height);
        };

        InteractiveLayer.prototype.getMouseTouchEnabled = function () {
            return this._mouseEnable;
        };

        InteractiveLayer.prototype.getMc = function () {
            return this;
        };

        InteractiveLayer.prototype.setName = function (v) {
            this._name = name;
        };

        InteractiveLayer.prototype.getName = function () {
            return this._name;
        };

        InteractiveLayer.prototype.addEventListener = function (eventType, theHandler, listener) {
            if (typeof listener === "undefined") { listener = null; }
            this._ed.addEventListener(eventType, theHandler, listener);
        };

        // remove a listener
        InteractiveLayer.prototype.removeEventListener = function (eventType, theHandler) {
            this._ed.removeEventListener(eventType, theHandler);
        };

        // remove all listeners
        InteractiveLayer.prototype.removeAllListeners = function (eventType) {
            this._ed.removeAllListeners(eventType);
        };

        InteractiveLayer.prototype.hasEventListener = function (eventType) {
            return this._ed.hasEventListener(eventType);
        };

        // dispatch event to all listeners
        InteractiveLayer.prototype.dispatchEvent = function (theEvent) {
            this._ed.dispatchEvent(theEvent);
        };

        // send event to a handler
        InteractiveLayer.prototype.dispatchEventToHander = function (theEvent, theHandler) {
            this._ed.dispatchEventToHander(theEvent, theHandler);
        };

        InteractiveLayer.prototype.onMouseDownTouchBegan = function (pos) {
            var local = this.convertToNodeSpace(pos);
            var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, local, pos);
            this._ed.dispatchEvent(e);
        };

        InteractiveLayer.prototype.onMouseTouchEndedUp = function (pos) {
            var local = this.convertToNodeSpace(pos);
            var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, local, pos);
            this._ed.dispatchEvent(e);
        };

        InteractiveLayer.prototype.onMouseDraggedTouchMove = function (pos) {
            var local = this.convertToNodeSpace(pos);
            var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, local, pos);
            this._ed.dispatchEvent(e);
        };
        return InteractiveLayer;
    })(cc.Layer);
    tx.InteractiveLayer = InteractiveLayer;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var InteractiveSprite = (function (_super) {
        __extends(InteractiveSprite, _super);
        function InteractiveSprite() {
            _super.call(this);
            this._isOver = false;
            this._name = typeof (this) + tx.DisplayObject.DisplayObjectCreateNum++;
            this._mouseEnable = false;
            this._ed = new tx.EventDispatcher(this);
            this._touchLayer = cc.Layer.create();
            this.addChild(this._touchLayer);
        }
        InteractiveSprite.createWithSpriteFrame = function (spriteFrame) {
            var sprite = new InteractiveSprite();
            if (sprite && sprite.initWithSpriteFrame(spriteFrame)) {
                return sprite;
            }
            return null;
        };

        InteractiveSprite.createWithTexture = function (texture) {
            var sprite = new InteractiveSprite();
            if (sprite && sprite.initWithTexture(texture)) {
                return sprite;
            }
            return null;
        };

        InteractiveSprite.prototype.destroy = function () {
            this.removeChild(this._touchLayer);
            this._touchLayer = null;
            this._ed.destroy();
            this._ed = null;
        };

        InteractiveSprite.prototype.setMouseTouchEnabled = function (b) {
            if (this._mouseEnable != b) {
                this._mouseEnable = b;
                if (b) {
                    tx.interactiveObjectCreate(this._touchLayer, this);
                } else {
                    tx.interactiveObjectRemove(this._touchLayer);
                }
            }
        };

        InteractiveSprite.prototype.getMouseTouchEnabled = function () {
            return this._mouseEnable;
        };

        InteractiveSprite.prototype.getTouchLayer = function () {
            return this._touchLayer;
        };
        InteractiveSprite.prototype.getWidth = function () {
            return this.getBoundingBox().width;
        };

        InteractiveSprite.prototype.getHeight = function () {
            return this.getBoundingBox().height;
        };

        InteractiveSprite.prototype.setWidth = function (v) {
            this.setScaleX(v / this.getContentSize().width);
        };

        InteractiveSprite.prototype.setHeight = function (v) {
            this.setScaleY(v / this.getContentSize().height);
        };

        InteractiveSprite.prototype.getMc = function () {
            return this;
        };

        InteractiveSprite.prototype.setName = function (v) {
            this._name = v;
        };

        InteractiveSprite.prototype.getName = function () {
            return this._name;
        };

        InteractiveSprite.prototype.addEventListener = function (eventType, theHandler, listener) {
            if (typeof listener === "undefined") { listener = null; }
            this._ed.addEventListener(eventType, theHandler, listener);
        };

        // remove a listener
        InteractiveSprite.prototype.removeEventListener = function (eventType, theHandler) {
            this._ed.removeEventListener(eventType, theHandler);
        };

        // remove all listeners
        InteractiveSprite.prototype.removeAllListeners = function (eventType) {
            this._ed.removeAllListeners(eventType);
        };

        InteractiveSprite.prototype.hasEventListener = function (eventType) {
            return this._ed.hasEventListener(eventType);
        };

        // dispatch event to all listeners
        InteractiveSprite.prototype.dispatchEvent = function (theEvent) {
            this._ed.dispatchEvent(theEvent);
        };

        // send event to a handler
        InteractiveSprite.prototype.dispatchEventToHander = function (theEvent, theHandler) {
            this._ed.dispatchEventToHander(theEvent, theHandler);
        };

        InteractiveSprite.prototype.onMouseDown = function (event) {
        };

        InteractiveSprite.prototype.onMouseDragged = function (event) {
        };

        InteractiveSprite.prototype.onMouseUp = function (event) {
        };

        InteractiveSprite.prototype.onTouchBegan = function (touch, event) {
        };

        InteractiveSprite.prototype.onTouchMoved = function (touch, event) {
        };

        InteractiveSprite.prototype.onTouchEnded = function (touch, event) {
        };

        InteractiveSprite.prototype.onTouchesBegan = function (touch, event) {
        };

        InteractiveSprite.prototype.onTouchesMoved = function (touch, event) {
        };

        InteractiveSprite.prototype.onTouchesEnded = function (touch, event) {
        };

        InteractiveSprite.prototype.isInRect = function (x, y, rect) {
            if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {
                return true;
            } else {
                return false;
            }
        };

        InteractiveSprite.prototype.onMouseDownTouchBegan = function (pos) {
            var local = this.convertToNodeSpace(pos);
            var rect = this.getBoundingBox();
            var offset = this._unflippedOffsetPositionFromCenter;
            if (this.isInRect(local.x - offset.x, local.y - offset.y, rect)) {
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, local, pos);
                this._ed.dispatchEvent(e);
            }
        };

        InteractiveSprite.prototype.onMouseTouchEndedUp = function (pos) {
            var local = this.convertToNodeSpace(pos);
            var rect = this.getBoundingBox();
            var offset = this._unflippedOffsetPositionFromCenter;
            if (this.isInRect(local.x - offset.x, local.y - offset.y, rect)) {
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, local, pos);
                this._ed.dispatchEvent(e);
            }
            if (this._isOver) {
                this._isOver = false;
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_TOUCH_OUT, local, pos);
                this._ed.dispatchEvent(e);
            }
        };

        InteractiveSprite.prototype.onMouseDraggedTouchMove = function (pos) {
            var local = this.convertToNodeSpace(pos);
            var rect = this.getBoundingBox();
            var offset = this._unflippedOffsetPositionFromCenter;
            if (this.isInRect(local.x - offset.x, local.y - offset.y, rect)) {
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, local, pos);
                this._ed.dispatchEvent(e);
                if (!this._isOver) {
                    this._isOver = true;
                    var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_TOUCH_OVER, local, pos);
                    this._ed.dispatchEvent(e);
                }
            } else {
                if (this._isOver) {
                    this._isOver = false;
                    var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_TOUCH_OUT, local, pos);
                    this._ed.dispatchEvent(e);
                }
            }
        };
        return InteractiveSprite;
    })(cc.Sprite);
    tx.InteractiveSprite = InteractiveSprite;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var InteractiveObject = (function (_super) {
        __extends(InteractiveObject, _super);
        function InteractiveObject(target) {
            if (typeof target === "undefined") { target = null; }
            _super.call(this, target);
            this._name = typeof (this) + tx.DisplayObject.DisplayObjectCreateNum++;
        }
        InteractiveObject.prototype.initWithLayer = function (mc) {
            this._mc = mc;
            tx.interactiveObjectCreate(mc, this);
        };

        InteractiveObject.prototype.destroy = function () {
            tx.interactiveObjectRemove(this._mc);
            this._mc = null;
            _super.prototype.destroy.call(this);
        };

        InteractiveObject.prototype.getMc = function () {
            return this._mc;
        };

        InteractiveObject.prototype.setName = function (v) {
            this._name = name;
        };

        InteractiveObject.prototype.getName = function () {
            return this._name;
        };

        InteractiveObject.prototype.onMouseDown = function (event) {
        };

        InteractiveObject.prototype.onMouseDragged = function (event) {
        };

        InteractiveObject.prototype.onMouseUp = function (event) {
        };

        InteractiveObject.prototype.onTouchBegan = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchMoved = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchEnded = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchesBegan = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchesMoved = function (touch, event) {
        };

        InteractiveObject.prototype.onTouchesEnded = function (touch, event) {
        };

        InteractiveObject.prototype.onMouseDownTouchBegan = function (pos) {
            var local = this._mc.convertToNodeSpace(pos);
            var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, local, pos);
            this.dispatchEvent(e);
        };

        InteractiveObject.prototype.onMouseTouchEndedUp = function (pos) {
            var local = this._mc.convertToNodeSpace(pos);
            var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, local, pos);
            this.dispatchEvent(e);
        };

        InteractiveObject.prototype.onMouseDraggedTouchMove = function (pos) {
            var local = this._mc.convertToNodeSpace(pos);
            var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, local, pos);
            this.dispatchEvent(e);
        };
        return InteractiveObject;
    })(tx.EventDispatcher);
    tx.InteractiveObject = InteractiveObject;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var TextureAtlas = (function () {
        function TextureAtlas(plist, texture) {
            this.sNames = [];
            tx.Attach.addSpriteFrames(plist);
            this.parseAtlasXml(plist);
        }
        TextureAtlas.FindPlistInDict = function (prefix) {
            if (TextureAtlas.CacheHelpFindPlistInDict[prefix] != null) {
                return TextureAtlas.CacheHelpFindPlistInDict[prefix];
            }
            var dict = cc.SAXParser.getInstance()._xmlDict;
            for (var key in dict) {
                var xmlDoc = cc.SAXParser.getInstance()._parserXML(dict[key], key);
                var plist = xmlDoc.documentElement;
                if (plist.tagName == 'plist') {
                    var dict2 = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(key);
                    var mTextureRegions = dict2["frames"];
                    for (var name in mTextureRegions) {
                        if (name.indexOf(prefix) == 0) {
                            TextureAtlas.CacheHelpFindPlistInDict[prefix] = tx.Utils.removeFullPathForFilename(key);
                            return TextureAtlas.CacheHelpFindPlistInDict[prefix];
                        }
                    }
                }
            }
            return null;
        };

        TextureAtlas.prototype.destroy = function () {
            this.sNames = null;
            this.mTextureRegions = null;
        };

        TextureAtlas.prototype.parseAtlasXml = function (atlasPlist) {
            atlasPlist = cc.FileUtils.getInstance().fullPathForFilename(atlasPlist);
            var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(atlasPlist);
            if (dict != null) {
                this.mTextureRegions = dict["frames"];
            } else {
                cc.log("no dict");
            }
        };

        TextureAtlas.prototype.getTexture = function (name) {
            return cc.SpriteFrameCache.getInstance().getSpriteFrame(name);
        };

        TextureAtlas.prototype.getTextures = function (prefix, result) {
            if (typeof prefix === "undefined") { prefix = ""; }
            if (typeof result === "undefined") { result = null; }
            if (result == null) {
                result = [];
            }

            this.sNames = this.getNames(prefix, this.sNames);
            for (var key in this.sNames) {
                result.push(this.getTexture(this.sNames[key]));
            }

            this.sNames = [];
            return result;
        };

        TextureAtlas.prototype.getNames = function (prefix, result) {
            if (typeof prefix === "undefined") { prefix = ""; }
            if (typeof result === "undefined") { result = null; }
            if (result == null) {
                result = [];
            }

            for (var name in this.mTextureRegions) {
                if (name.indexOf(prefix) == 0) {
                    result.push(name);
                }
            }

            //            function sortNumber(a, b) {
            //                return a - b
            //            }
            result.sort();
            return result;
        };
        TextureAtlas.CacheHelpFindPlistInDict = {};
        return TextureAtlas;
    })();
    tx.TextureAtlas = TextureAtlas;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var DragObject = (function (_super) {
        __extends(DragObject, _super);
        function DragObject(targetMc, iObject, touchLayer, fixedPos) {
            _super.call(this, targetMc);
            this._mc = targetMc;
            this._iObject = iObject;
            this._fixedPos = fixedPos;
            this._touchLayer = touchLayer;
            this._startDragStartPos = cc.p(targetMc.getPosition().x, targetMc.getPosition().y);
            if (iObject != null) {
                iObject.addEventListener.call(iObject, tx.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, this.onEventMouseTouchBegin, this);
                iObject.addEventListener.call(iObject, tx.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, this.onEventMouseTouchEnded, this);
                iObject.addEventListener.call(iObject, tx.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, this.onEventMouseTouchMove, this);
            } else if (this._touchLayer != null) {
                tx.interactiveObjectCreate(this._touchLayer, this);
            }
            //            iObject.addEventListener()
        }
        DragObject.StartDragByInteractiveObject = function (iObject) {
            DragObject.EndDragByInteractiveObject(iObject);
            var temp = new DragObject(iObject.getMc(), iObject, null, true);
            DragObject._dragHander.push(temp);
        };

        DragObject.EndDragByInteractiveObject = function (mc) {
            for (var i = 0; i < DragObject._dragHander.length; i++) {
                if (DragObject._dragHander[i].getMc() == mc.getMc()) {
                    DragObject._dragHander[i].destroy();
                    DragObject._dragHander.splice(i, 1);
                    return;
                }
            }
        };

        DragObject.StartDrag = function (targetMc, touchLayer) {
            if (typeof touchLayer === "undefined") { touchLayer = null; }
            DragObject.EndDrag(targetMc);
            if (targetMc instanceof tx.InteractiveNodeRGBA) {
                touchLayer = targetMc.getTouchLayer();
            } else if (targetMc instanceof cc.Layer) {
                touchLayer = targetMc;
            } else if (!(touchLayer instanceof cc.Layer)) {
                return;
            }
            var temp = new DragObject(targetMc, null, touchLayer, true);
            DragObject._dragHander.push(temp);
        };

        DragObject.EndDrag = function (targetMc) {
            for (var i = 0; i < DragObject._dragHander.length; i++) {
                if (DragObject._dragHander[i].getMc() == targetMc) {
                    DragObject._dragHander[i].destroy();
                    DragObject._dragHander.splice(i, 1);
                    return;
                }
            }
        };

        DragObject.SetInteractiveObjectToDragObject = function (mc) {
            DragObject.RemoveInteractiveObjectDragObject(mc);
            var temp = new DragObject(mc.getMc(), mc);
            DragObject._setDragHander.push(temp);
        };

        DragObject.RemoveInteractiveObjectDragObject = function (mc) {
            for (var i = 0; i < DragObject._setDragHander.length; i++) {
                if (DragObject._setDragHander[i].getMc() == mc.getMc()) {
                    DragObject._setDragHander[i].destroy();
                    DragObject._setDragHander.splice(i, 1);
                    return;
                }
            }
        };

        DragObject.SetToDragObject = function (targetMc, touchLayer) {
            if (typeof touchLayer === "undefined") { touchLayer = null; }
            DragObject.RemoveDragObject(targetMc);

            //            if (targetMc instanceof tx.InteractiveNodeRGBA) {
            //                touchLayer = (<tx.InteractiveNodeRGBA>targetMc).getTouchLayer();
            //            }
            if (targetMc["getTouchLayer"] != null) {
                touchLayer = targetMc["getTouchLayer"]();
            } else if (targetMc instanceof cc.Layer) {
                touchLayer = targetMc;
            } else if (!(touchLayer instanceof cc.Layer)) {
                return;
            }
            var temp = new DragObject(targetMc, null, touchLayer);
            DragObject._setDragHander.push(temp);
        };

        DragObject.RemoveDragObject = function (targetMc) {
            for (var i = 0; i < DragObject._setDragHander.length; i++) {
                if (DragObject._setDragHander[i].getMc() == targetMc) {
                    DragObject._setDragHander[i].destroy();
                    DragObject._setDragHander.splice(i, 1);
                    return;
                }
            }
        };

        DragObject.prototype.destroy = function () {
            if (this._touchLayer != null) {
                tx.interactiveObjectRemove(this._touchLayer);
            }
            if (this._iObject != null) {
                this._iObject.removeEventListener.call(this._iObject, tx.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, this.onEventMouseTouchBegin);
                this._iObject.removeEventListener.call(this._iObject, tx.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, this.onEventMouseTouchEnded);
                this._iObject.removeEventListener.call(this._iObject, tx.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, this.onEventMouseTouchMove);
            }
            this._mc = null;
        };

        DragObject.prototype.onEventMouseTouchBegin = function (e) {
            (e.listener).onMouseDownTouchBegan(e.worldPos);
        };

        DragObject.prototype.onEventMouseTouchEnded = function (e) {
            (e.listener).onMouseTouchEndedUp(e.worldPos);
        };

        DragObject.prototype.onEventMouseTouchMove = function (e) {
            (e.listener).onMouseDraggedTouchMove(e.worldPos);
        };

        DragObject.prototype.onMouseDownTouchBegan = function (pos) {
            if (!this._fixedPos) {
                this._startDragStartMousePos = new cc.Point(pos.x, pos.y);
                this._startDragStartPos = cc.p(this._mc.getPosition().x, this._mc.getPosition().y);
            }
        };

        DragObject.prototype.onMouseTouchEndedUp = function (pos) {
            if (!this._fixedPos) {
                this._startDragStartMousePos = null;
            }
        };

        DragObject.prototype.onMouseDraggedTouchMove = function (pos) {
            if (this._startDragStartMousePos == null) {
                this._startDragStartMousePos = new cc.Point(pos.x, pos.y);
            }
            var post = new cc.Point(pos.x, pos.y);
            post.x -= this._startDragStartMousePos.x;
            post.y -= this._startDragStartMousePos.y;
            this._mc.setPositionX(this._startDragStartPos.x + post.x);
            this._mc.setPositionY(this._startDragStartPos.y + post.y);
        };
        DragObject._dragHander = [];
        DragObject._setDragHander = [];
        return DragObject;
    })(tx.InteractiveObject);
    tx.DragObject = DragObject;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var Bitmap = (function (_super) {
        __extends(Bitmap, _super);
        function Bitmap(bmd) {
            _super.call(this);
            this._name = typeof (this) + tx.DisplayObject.DisplayObjectCreateNum++;
            this._isTransparent = true;
            this._isOver = false;
            this.setBitmapData(bmd);
        }
        Bitmap.prototype.destroy = function (isDestroyBmd) {
            if (typeof isDestroyBmd === "undefined") { isDestroyBmd = false; }
            if (this._bmd != null) {
                this._bmd.destroy();
            }
            this._bmd = null;
            _super.prototype.destroy.call(this);
        };

        Bitmap.prototype.setBitmapData = function (bmd) {
            this._bmd = bmd;
        };

        Bitmap.prototype.getBitmapData = function () {
            return this._bmd;
        };

        Bitmap.prototype.draw = function (ctx) {
            if (this._bmd != null) {
                ctx.globalAlpha = this.getDisplayedOpacity() / 255.0;
                var size = new cc.Size(cc.EGLView.getInstance().getScaleX() * this._bmd.getWidth(), cc.EGLView.getInstance().getScaleY() * this._bmd.getHeight());
                cc.drawingUtil.drawImage(this._bmd._getImageEle(), cc.p(0, 0), new cc.Size(this._bmd.getWidth(), this._bmd.getHeight()), cc.p(0, 0), size);
            }
        };

        Bitmap.prototype.setTransparent = function (isTransparent) {
            if (typeof isTransparent === "undefined") { isTransparent = true; }
            this._isTransparent = isTransparent;
        };

        Bitmap.prototype.getTransparent = function () {
            return this._isTransparent;
        };

        Bitmap.prototype.onMouseDownTouchBegan = function (pos) {
            //            trace("onMouseDownTouchBegan");
            var local = this.convertToNodeSpace(pos);
            var t = this._bmd.getPixel4B(local.x, this._bmd.getHeight() - local.y);

            //            trace(t.a);
            if (t && (!this._isTransparent || t.a > 0)) {
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DOWN_TOUCH_BEGAN, local, pos);
                this._ed.dispatchEvent(e);
            }
        };

        Bitmap.prototype.onMouseTouchEndedUp = function (pos) {
            //            trace("onMouseTouchEndedUp");
            var local = this.convertToNodeSpace(pos);
            var t = this._bmd.getPixel4B(local.x, this._bmd.getHeight() - local.y);

            //            trace(t.a);
            if (t && (!this._isTransparent || t.a > 0)) {
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_UP_TOUCH_ENDED, local, pos);
                this._ed.dispatchEvent(e);
            }
            if (this._isOver) {
                this._isOver = false;
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_TOUCH_OUT, local, pos);
                this._ed.dispatchEvent(e);
            }
        };

        Bitmap.prototype.onMouseDraggedTouchMove = function (pos) {
            //            trace("Bitmap.onMouseDraggedTouchMove", pos.x, pos.y);
            var local = this.convertToNodeSpace(pos);
            var t = this._bmd.getPixel4B(local.x, this._bmd.getHeight() - local.y);
            if (t && (!this._isTransparent || t.a > 0)) {
                var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_DRAGGED_TOUCH_MOVE, local, pos);
                this._ed.dispatchEvent(e);
                if (!this._isOver) {
                    this._isOver = true;
                    var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_TOUCH_OVER, local, pos);
                    this._ed.dispatchEvent(e);
                }
            } else {
                if (this._isOver) {
                    this._isOver = false;
                    var e = new tx.MouseTouchEvent(tx.MouseTouchEvent.MOUSE_TOUCH_OUT, local, pos);
                    this._ed.dispatchEvent(e);
                }
            }
        };
        return Bitmap;
    })(tx.InteractiveNodeRGBA);
    tx.Bitmap = Bitmap;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var BitmapData = (function () {
        function BitmapData(width, height, transparent, fillColor) {
            if (typeof transparent === "undefined") { transparent = true; }
            if (typeof fillColor === "undefined") { fillColor = 0xFFFFFFFF; }
            this._lock = false;
            this._width = width;
            this._height = height;
            this._transparent = transparent;
            this._fillColor = fillColor;

            this._temp_Canvas = document.createElement("canvas");
            this._temp_ctx = this._temp_Canvas.getContext("2d");
            this._temp_Canvas.width = this._width;
            this._temp_Canvas.height = this._height;
            var color = this._fillColor % 0x1000000;
            var alpha = this._transparent ? ((this._fillColor >> 24) % 0x100) : 255;
            this._temp_ctx.fillStyle = tx.Utils.UINT_TO_3STRING(color);
            this._temp_ctx.globalAlpha = alpha / 255;
            this._temp_ctx.fillRect(0, 0, this._width, this._height);
            this._temp_ctx.globalAlpha = 1;
            this._ImgData = this._temp_ctx.createImageData(this._width, this._height);
            //TODO:默认颜色填充
        }
        BitmapData.prototype.destroy = function () {
            this._temp_ctx = null;
            this._temp_Canvas = null;
            this._ImgData = null;
        };

        BitmapData.prototype.clone = function () {
            var temp = new BitmapData(this._width, this._height, this._transparent, this._fillColor);
            temp._ImgData = this._temp_ctx.createImageData(this._width, this._height);
            for (var i = 0; i < this._ImgData.data.length; i += 4) {
                temp._ImgData.data[i] = this._ImgData.data[i];
            }
            temp.updateImageEle();
            return temp;
        };

        BitmapData.prototype.draw = function (soucre, matrix, colorTransform, blendMode, clipRect, smoothing) {
            if (typeof matrix === "undefined") { matrix = null; }
            if (typeof colorTransform === "undefined") { colorTransform = null; }
            if (typeof blendMode === "undefined") { blendMode = null; }
            if (typeof clipRect === "undefined") { clipRect = null; }
            if (typeof smoothing === "undefined") { smoothing = false; }
            var _this = this;
            cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);
            var oldParent = soucre.getParent();
            if (oldParent) {
                oldParent.removeChild(soucre);
            }

            if (clipRect == null) {
                clipRect = new cc.Rect(0, 0, this._width, this._height);
            }

            //转换全局缩放
            if (BitmapData.GlobalResolutionEnblen) {
                if (cc.EGLView.getInstance()._resolutionPolicy != cc.RESOLUTION_POLICY.UNKNOWN) {
                    var designResolutionSize = cc.EGLView.getInstance().getDesignResolutionSize();
                    cc.EGLView.getInstance()._frameSize = designResolutionSize;
                    var result = cc.EGLView.getInstance()._rpShowAll.apply(cc.EGLView.getInstance(), designResolutionSize);
                    cc.EGLView.getInstance()._setScaleXYForRenderTexture();
                    //                    cc.EGLView.getInstance().setFrameSize(designResolutionSize.width, designResolutionSize.height);
                    //                    if ((cc.EGLView.getInstance())["_adjustSize"]) {
                    //                        cc.EGLView.getInstance()._adjustSize();
                    //                    }
                }
            }

            var scene = cc.Scene.create();
            scene.addChild(soucre);

            //record tranMatrix;
            if (matrix == null) {
                matrix = new tx.Matrix(1, 0, 0, 1, 0, 0);
            }
            var oldTran = soucre.nodeToParentTransform();
            soucre._transform = matrix;

            scene.draw = function (ctx) {
                var color = _this._fillColor % 0x1000000;
                var alpha = _this._transparent ? ((_this._fillColor >> 24) % 0x100) : 255;
                ctx.fillStyle = tx.Utils.UINT_TO_3STRING(color);
                ctx.globalAlpha = alpha / 255;
                ctx.fillRect(0, 0, _this._width, -_this._height);
                ctx.globalAlpha = 1;
            };

            var tempNode = new cc.Node();
            scene.addChild(tempNode);
            tempNode.draw = function (ctx) {
                _this._ImgData = ctx.getImageData(clipRect.x, cc.canvas.height - _this._height + clipRect.y, clipRect.width, clipRect.height);

                //                for (var i = 0; i < this._ImgData.data.length; i += 4) {
                //                    cc.log
                //                    this._ImgData.data[i] = 255 - this._ImgData.data[i];
                //                    this._ImgData.data[i + 1] = 255 - this._ImgData.data[i + 1];
                //                    this._ImgData.data[i + 2] = 255 - this._ImgData.data[i + 2];
                //                    this._ImgData.data[i + 3] = 255;
                //                }
                //                this._temp_ctx.putImageData(this._ImgData, 0, 0);
                _this.updateImageEle();

                //recover
                soucre._transform = oldTran;
                scene.removeChild(soucre);
                if (oldParent) {
                    oldParent.addChild(soucre);
                }

                //还原全局缩放
                if (BitmapData.GlobalResolutionEnblen) {
                    if (cc.EGLView.getInstance()._resolutionPolicy != cc.RESOLUTION_POLICY.UNKNOWN) {
                        cc.EGLView.getInstance().setDesignResolutionSize(designResolutionSize.width, designResolutionSize.height, cc.EGLView.getInstance()._resolutionPolicy);
                        //                        if ((cc.EGLView.getInstance())["_adjustSize"]) {
                        //                            cc.EGLView.getInstance()._adjustSize();
                        //                        }
                    }
                }
            };
            scene.visit();

            //解决闪屏问题的bug
            cc.Director.getInstance().getRunningScene().visit();
        };

        BitmapData.prototype.isInRect = function (x, y) {
            if (x >= 0 && y >= 0 && x <= this._width && y <= this._height) {
                return true;
            } else {
                return false;
            }
        };

        BitmapData.prototype.setPixel = function (x, y, color) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var c = tx.Utils.COLOR_3B(color);

                //            trace(c.r, c.g, c.b);
                this._ImgData.data[(y * this._width + x) * 4] = c.r;
                this._ImgData.data[((y * this._width + x) * 4) + 1] = c.g;
                this._ImgData.data[((y * this._width + x) * 4) + 2] = c.b;
                this._ImgData.data[((y * this._width + x) * 4) + 3] = 1;
                this.updateImageEle();
            }
        };

        BitmapData.prototype.setPixel32 = function (x, y, color) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var c = tx.Utils.COLOR_4B(color);

                //            trace(c.r, c.g, c.b, c.a);
                this._ImgData.data[(y * this._width + x) * 4] = c.r;
                this._ImgData.data[((y * this._width + x) * 4) + 1] = c.g;
                this._ImgData.data[((y * this._width + x) * 4) + 2] = c.b;
                this._ImgData.data[((y * this._width + x) * 4) + 3] = c.a;
                this.updateImageEle();
            }
        };

        BitmapData.prototype.getPixel = function (x, y) {
            var color = this.getPixel3B(x, y);
            if (color) {
                return tx.Utils.C3B_TO_UINT(color);
            } else {
                return NaN;
            }
        };

        BitmapData.prototype.getPixel3B = function (x, y) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var r = this._ImgData.data[(y * this._width + x) * 4];
                var g = this._ImgData.data[((y * this._width + x) * 4) + 1];
                var b = this._ImgData.data[((y * this._width + x) * 4) + 2];
                return new cc.Color3B(r, g, b);
            } else {
                return null;
            }
        };

        BitmapData.prototype.getPixel32 = function (x, y) {
            var color = this.getPixel4B(x, y);
            if (color) {
                return tx.Utils.C4B_TO_UINT(color);
            } else {
                return NaN;
            }
        };

        BitmapData.prototype.getPixel4B = function (x, y) {
            if (this.isInRect(x, y)) {
                x = Math.floor(x);
                y = Math.floor(y);
                var r = this._ImgData.data[(y * this._width + x) * 4];
                var g = this._ImgData.data[((y * this._width + x) * 4) + 1];
                var b = this._ImgData.data[((y * this._width + x) * 4) + 2];
                var a = this._ImgData.data[((y * this._width + x) * 4) + 3];
                return new cc.Color4B(r, g, b, a);
            } else {
                return null;
            }
        };

        BitmapData.prototype.lock = function () {
            this._lock = true;
        };

        BitmapData.prototype.unlock = function () {
            if (this._lock == true) {
                this._lock = false;
                this.updateImageEle();
            }
        };

        BitmapData.prototype._getImgData = function () {
            return this._ImgData;
        };

        BitmapData.prototype._getImageEle = function () {
            return this._temp_Canvas;
        };

        BitmapData.prototype.getData = function () {
            return this._ImgData.data;
        };

        BitmapData.prototype.setData = function (data) {
            this._ImgData.data = data;
            this.updateImageEle();
        };

        BitmapData.prototype.updateImageEle = function () {
            if (!this._lock) {
                this._temp_ctx.clearRect(0, 0, this._width, this._height);
                this._temp_ctx.putImageData(this._ImgData, 0, 0);
            }
        };

        BitmapData.prototype.getWidth = function () {
            return this._width;
        };

        BitmapData.prototype.getHeight = function () {
            return this._height;
        };
        BitmapData.GlobalResolutionEnblen = true;
        return BitmapData;
    })();
    tx.BitmapData = BitmapData;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var MovieClip = (function (_super) {
        __extends(MovieClip, _super);
        function MovieClip(textures, fps) {
            if (typeof fps === "undefined") { fps = 12; }
            var _this = this;
            _super.call(this);
            if (textures.length > 0) {
                this.mTexture = textures[0];
                this.mFrameScript = [];
                _super.prototype.initWithSpriteFrame.call(this, textures[0]);
                this._init(textures, fps);
                this.schedule(function () {
                    _this.advanceTime(cc.Director.getInstance().getAnimationInterval());
                }, cc.Director.getInstance().getAnimationInterval());
            } else {
                trace("empty texture array");
            }
        }
        MovieClip.prototype.destroy = function () {
            this.mTexture = null;
            this.mTextures = null;
            this.mFrameScript = null;
            this.mDurations = null;
            this.mStartTimes = null;
            _super.prototype.destroy.call(this);
        };

        MovieClip.prototype._init = function (textures, fps) {
            if (fps <= 0) {
                trace("Invalid fps: " + fps);
            }
            var numFrames = textures.length;

            this.mDefaultFrameDuration = 1.0 / fps;
            this.mLoop = true;
            this.mPlaying = true;
            this.mCurrentTime = 0.0;
            this.mCurrentFrame = 0;
            this.mTextures = textures.concat();

            //            this.mSounds = new Vector. < Sound > (numFrames);
            this.mDurations = new Array(numFrames);
            this.mStartTimes = new Array(numFrames);

            for (var i = 0; i < numFrames; ++i) {
                this.mDurations[i] = this.mDefaultFrameDuration;
                this.mStartTimes[i] = i * this.mDefaultFrameDuration;
            }
        };

        /** Adds an additional frame, optionally with a sound and a custom duration. If the
        *  duration is omitted, the default framerate is used (as specified in the constructor). */
        MovieClip.prototype.addFrame = function (texture, sound, duration) {
            if (typeof sound === "undefined") { sound = null; }
            if (typeof duration === "undefined") { duration = -1; }
            this.addFrameAt(this.getNumFrames(), texture, sound, duration);
        };

        /** Adds a frame at a certain index, optionally with a sound and a custom duration. */
        MovieClip.prototype.addFrameAt = function (frameID, texture, sound, duration) {
            if (typeof sound === "undefined") { sound = null; }
            if (typeof duration === "undefined") { duration = -1; }
            if (frameID < 0 || frameID > this.getNumFrames()) {
                trace("Invalid frame id");
            }
            if (duration < 0) {
                duration = this.mDefaultFrameDuration;
            }

            this.mTextures.splice(frameID, 0, texture);

            //            this.mSounds.splice(frameID, 0, sound);
            this.mDurations.splice(frameID, 0, duration);

            if (frameID > 0 && frameID == this.getNumFrames())
                this.mStartTimes[frameID] = this.mStartTimes[Math.floor(frameID - 1)] + this.mDurations[Math.floor(frameID - 1)];
            else
                this.updateStartTimes();
        };

        /** Removes the frame at a certain ID. The successors will move down. */
        MovieClip.prototype.removeFrameAt = function (frameID) {
            if (frameID < 0 || frameID >= this.getNumFrames()) {
                trace("Invalid frame id");
            }
            if (this.getNumFrames() == 1) {
                trace("Movie clip must not be empty");
            }

            this.mTextures.splice(frameID, 1);

            //        this.mSounds.splice(frameID, 1);
            this.mDurations.splice(frameID, 1);

            this.updateStartTimes();
        };

        /** Returns the texture of a certain frame. */
        MovieClip.prototype.getFrameTexture = function (frameID) {
            if (frameID < 0 || frameID >= this.getNumFrames()) {
                trace("Invalid frame id");
            }
            return this.mTextures[frameID];
        };

        /** Sets the texture of a certain frame. */
        MovieClip.prototype.setFrameTexture = function (frameID, texture) {
            if (frameID < 0 || frameID >= this.getNumFrames()) {
                trace("Invalid frame id");
            }
            this.mTextures[frameID] = texture;
        };

        /** Returns the sound of a certain frame. */
        //        public getFrameSound(frameID:number):Sound {
        //            if (frameID < 0 || frameID >= this.getNumFrames())  {trace("Invalid frame id")};
        //            return this.mSounds[frameID];
        //        }
        /** Sets the sound of a certain frame. The sound will be played whenever the frame
        *  is displayed. */
        //        public setFrameSound(frameID:number, sound:Sound):void {
        //            if (frameID < 0 || frameID >= this.getNumFrames()) {
        //                trace("Invalid frame id");
        //            }
        //            this.mSounds[frameID] = sound;
        //        }
        /** Returns the duration of a certain frame (in seconds). */
        MovieClip.prototype.getFrameDuration = function (frameID) {
            if (frameID < 0 || frameID >= this.getNumFrames()) {
                trace("Invalid frame id");
            }
            return this.mDurations[frameID];
        };

        /** Sets the duration of a certain frame (in seconds). */
        MovieClip.prototype.setFrameDuration = function (frameID, duration) {
            if (frameID < 0 || frameID >= this.getNumFrames()) {
                trace("Invalid frame id");
            }
            this.mDurations[frameID] = duration;
            this.updateStartTimes();
        };

        /** Starts playback. Beware that the clip has to be added to a juggler, too! */
        MovieClip.prototype.play = function () {
            this.mPlaying = true;
        };

        /** Pauses playback. */
        MovieClip.prototype.pause = function () {
            this.mPlaying = false;
        };

        /** Stops playback, resetting "currentFrame" to zero. */
        MovieClip.prototype.stop = function () {
            this.mPlaying = false;
            this.setCurrentFrame(0);
        };

        MovieClip.prototype.gotoAndPlay = function (v) {
            this.mPlaying = true;
            this.setCurrentFrame(v - 1);
        };

        MovieClip.prototype.gotoAndStop = function (v) {
            this.mPlaying = false;
            this.setCurrentFrame(v - 1);
        };

        MovieClip.prototype.addFrameScript = function (v, f, _this) {
            if (typeof _this === "undefined") { _this = null; }
            if (f != null) {
                this.mFrameScript[v] = [f, _this];
            }
        };

        // helpers
        MovieClip.prototype.updateStartTimes = function () {
            var numFrames = this.getNumFrames();

            this.mStartTimes.length = 0;
            this.mStartTimes[0] = 0;

            for (var i = 1; i < numFrames; ++i)
                this.mStartTimes[i] = this.mStartTimes[Math.floor(i - 1)] + this.mDurations[Math.floor(i - 1)];
        };

        // IAnimatable
        /** @inheritDoc */
        MovieClip.prototype.advanceTime = function (passedTime) {
            if (!this.mPlaying || passedTime <= 0.0)
                return;

            var finalFrame;
            var previousFrame = this.mCurrentFrame;
            var restTime = 0.0;
            var breakAfterFrame = false;
            var hasCompleteListener = this._ed.hasEventListener(tx.Event.COMPLETE);
            var dispatchCompleteEvent = false;
            var totalTime = this.getTotalTime();

            if (this.mLoop && this.mCurrentTime == totalTime) {
                this.mCurrentTime = 0.0;
                this.mCurrentFrame = 0;
            }

            if (this.mCurrentTime < totalTime) {
                this.mCurrentTime += passedTime;
                finalFrame = this.mTextures.length - 1;

                while (this.mCurrentTime > this.mStartTimes[this.mCurrentFrame] + this.mDurations[this.mCurrentFrame]) {
                    if (this.mCurrentFrame == finalFrame) {
                        if (this.mLoop && !hasCompleteListener) {
                            this.mCurrentTime -= totalTime;
                            this.mCurrentFrame = 0;
                        } else {
                            breakAfterFrame = true;
                            restTime = this.mCurrentTime - totalTime;
                            dispatchCompleteEvent = hasCompleteListener;
                            this.mCurrentFrame = finalFrame;
                            this.mCurrentTime = totalTime;
                        }
                    } else {
                        this.mCurrentFrame++;

                        // special case when we reach *exactly* the total time.
                        if (this.mCurrentFrame == finalFrame && this.mCurrentTime == totalTime)
                            dispatchCompleteEvent = hasCompleteListener;
                    }

                    //                    var sound:Sound = this.mSounds[this.mCurrentFrame];
                    //                    if (sound) sound.play();
                    if (this.mCurrentFrame != previousFrame) {
                        this.runFrameScript();
                    }
                    if (breakAfterFrame)
                        break;
                }
            }

            if (this.mCurrentFrame != previousFrame)
                this._setTexture(this.mTextures[this.mCurrentFrame]);

            if (dispatchCompleteEvent)
                this.dispatchEvent(new tx.Event(tx.Event.COMPLETE));

            if (this.mLoop && restTime != 0)
                this.advanceTime(restTime);
        };

        /** Indicates if a (non-looping) movie has come to its end. */
        MovieClip.prototype.isComplete = function () {
            return !this.mLoop && this.mCurrentTime >= this.getTotalTime();
        };

        /** The total duration of the clip in seconds. */
        MovieClip.prototype.getTotalTime = function () {
            var numFrames = this.mTextures.length;
            return this.mStartTimes[Math.floor(numFrames - 1)] + this.mDurations[Math.floor(numFrames - 1)];
        };

        /** The time that has passed since the clip was started (each loop starts at zero). */
        MovieClip.prototype.getCurrentTime = function () {
            return this.mCurrentTime;
        };

        /** The total number of frames. */
        MovieClip.prototype.getNumFrames = function () {
            return this.mTextures.length;
        };

        /** Indicates if the clip should loop. */
        MovieClip.prototype.getLoop = function () {
            return this.mLoop;
        };

        MovieClip.prototype.setLoop = function (value) {
            this.mLoop = value;
        };

        /** The index of the frame that is currently displayed. */
        MovieClip.prototype.getCurrentFrame = function () {
            return this.mCurrentFrame;
        };

        MovieClip.prototype.setCurrentFrame = function (value) {
            if (value < 0) {
                value = 0;
            }
            if (value >= this.getNumFrames()) {
                value = this.getNumFrames() - 1;
            }
            this.mCurrentTime = 0.0;
            for (var i = 0; i < value; ++i) {
                this.mCurrentTime += this.getFrameDuration(i);
            }
            if (this.mCurrentFrame != value) {
                this.mCurrentFrame = value;
                this.runFrameScript();
                this._setTexture(this.mTextures[this.mCurrentFrame]);
                //            if (this.mSounds[this.mCurrentFrame]) this.mSounds[this.mCurrentFrame].play();
            }
        };

        /** The default number of frames per second. Individual frames can have different
        *  durations. If you change the fps, the durations of all frames will be scaled
        *  relatively to the previous value. */
        MovieClip.prototype.getFps = function () {
            return 1.0 / this.mDefaultFrameDuration;
        };

        MovieClip.prototype.setFps = function (value) {
            if (value <= 0) {
                trace("Invalid fps: " + value);
            }

            var newFrameDuration = 1.0 / value;
            var acceleration = newFrameDuration / this.mDefaultFrameDuration;
            this.mCurrentTime *= acceleration;
            this.mDefaultFrameDuration = newFrameDuration;

            for (var i = 0; i < this.getNumFrames(); ++i) {
                var duration = this.mDurations[i] * acceleration;
                this.mDurations[i] = duration;
            }
            this.updateStartTimes();
        };

        /** Indicates if the clip is still playing. Returns <code>false</code> when the end
        *  is reached. */
        MovieClip.prototype.isPlaying = function () {
            if (this.mPlaying)
                return this.mLoop || this.mCurrentTime < this.getTotalTime();
            else
                return false;
        };

        MovieClip.prototype.runFrameScript = function () {
            var t = this.mFrameScript[this.mCurrentFrame];
            if (t != null) {
                t[1] = t[1] || this;
                t[0].call(t[1]);
            }
        };

        ///////////////////////////////starling Image////////////////////////
        /** The texture that is displayed on the quad. */
        MovieClip.prototype._getTexture = function () {
            return this.mTexture;
        };

        MovieClip.prototype._setTexture = function (value) {
            if (value == null) {
                trace("Texture cannot be null");
            } else if (value != this.mTexture) {
                this.mTexture = value;
                _super.prototype.setDisplayFrame.call(this, this.mTexture);
            }
        };
        return MovieClip;
    })(tx.InteractiveSprite);
    tx.MovieClip = MovieClip;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var Matrix = (function (_super) {
        __extends(Matrix, _super);
        function Matrix() {
            _super.apply(this, arguments);
        }
        return Matrix;
    })(cc.AffineTransform);
    tx.Matrix = Matrix;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
/**
* Created with JetBrains WebStorm.
* User: admin
* Date: 13-9-18
* Time: 下午2:46
* To change this template use File | Settings | File Templates.
*/
function getQualifiedClassName(ob) {
    //通过构造函数获得类名
    return ob["constructor"].name;
}

function getDefinitionByName(name, module) {
    if (typeof module === "undefined") { module = null; }
    if (module == null) {
        return eval(name + ".prototype.constructor");
    } else {
        return eval(module + "." + name + ".prototype.constructor");
    }
}

var tx;
(function (tx) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.SET_COLOR_4B_BY_UINT = function (drawingUtil, uintNumber, alpha) {
            drawingUtil.setDrawColor4B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100, alpha);
            //        var tt:number = 0x7FFF00F7;
            //        cc.log((uintNumber).toString(16));
            //        cc.log(((uintNumber>>0)%0x100).toString(16));
            //        cc.log(((uintNumber>>8)%0x100).toString(16));
            //        cc.log(((uintNumber>>16)%0x100).toString(16));
        };

        Utils.COLOR_4F = function (uintNumber, alpha) {
            if (typeof alpha === "undefined") { alpha = 1; }
            return new cc.Color4F(((uintNumber >>> 16) % 0x100) / 255, ((uintNumber >>> 8) % 0x100) / 255, ((uintNumber >>> 0) % 0x100) / 255, alpha);
        };

        Utils.COLOR_4B_Trans = function (uintNumber, colorTransform) {
            return new cc.Color4B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100, colorTransform ? ((uintNumber >>> 24) % 0x100) : 255);
        };

        Utils.COLOR_3B = function (uintNumber) {
            return new cc.Color3B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100);
        };

        Utils.COLOR_4B = function (uintNumber) {
            //            trace("aaa",uintNumber,(uintNumber >> 16));
            //                    var tt:number = 0x80FF00F7;
            //
            //            cc.log((uintNumber).toString(16));
            //            cc.log(((uintNumber>>0)%0x100).toString(16));
            //            uintNumber = tt;
            //        cc.log((uintNumber).toString());
            //        cc.log((uintNumber).toString(16));
            //        cc.log(((uintNumber>>0)%0x100).toString(16));
            //        cc.log(((uintNumber>>8)%0x100).toString(16));
            //        cc.log(((uintNumber>>16)%0x100).toString(16));
            //            cc.log(((uintNumber>>>0)%0x100).toString(16));
            //            cc.log(((uintNumber>>>8)%0x100).toString(16));
            //            cc.log(((uintNumber>>>16)%0x100).toString(16));
            //            cc.log(((uintNumber>>>24)%0x100).toString(16));
            //
            return new cc.Color4B((uintNumber >>> 16) % 0x100, (uintNumber >>> 8) % 0x100, (uintNumber >>> 0) % 0x100, (uintNumber >>> 24) % 0x100);
        };

        Utils.C4B_TO_UINT = function (c4b) {
            return Utils.COLOR_4B_TO_UINT(c4b.r, c4b.g, c4b.b, c4b.a);
        };

        Utils.C3B_TO_UINT = function (c3b) {
            return Utils.COLOR_3B_TO_UINT(c3b.r, c3b.g, c3b.b);
        };

        Utils.COLOR_4B_TO_UINT = function (r, g, b, a) {
            return a * 0x1000000 + r * 0x10000 + g * 0x100 + b;
        };

        Utils.COLOR_3B_TO_UINT = function (r, g, b) {
            return r * 0x10000 + g * 0x100 + b;
        };

        Utils.UINT_TO_3STRING = function (uintNumber) {
            var ret = uintNumber.toString(16);
            for (var i = ret.length; i < 6; i++) {
                ret = "0" + ret;
            }
            return ret;
        };

        Utils.CheckPosInMenuRect = function (menuItem, pos) {
            var local = menuItem.convertToNodeSpace(pos);
            var r = menuItem.rect();
            r.x = 0;
            r.y = 0;
            return cc.rectContainsPoint(r, local);
        };

        //=.=放大点
        Utils.CheckPosInMenuRect2 = function (menuItem, pos, offset) {
            if (typeof offset === "undefined") { offset = 0; }
            var local = menuItem.convertToNodeSpace(pos);
            var r = menuItem.rect();
            r.x = 0 - offset;
            r.y = 0 - offset;
            r.width += offset + offset;
            r.height += offset + offset;
            return cc.rectContainsPoint(r, local);
        };

        Utils.FadeOutAndRemoveFromParent = function (sprite, sec) {
            var removeFromParentAndCleanup = function (nodeExecutingAction, data) {
                nodeExecutingAction.removeFromParent(data);
            };
            var returnFunction = function () {
                return removeFromParentAndCleanup;
            };

            var action = cc.Sequence.create(cc.FadeOut.create(sec), cc.CallFunc.create(returnFunction(), sprite, true));
            sprite.runAction(action);

            var children = sprite.getChildren();
            for (var i = 0; i < children.length; i++) {
                Utils.AllFadeOut(children[i], sec);
            }
        };

        Utils.AllFadeIn = function (node, time) {
            if (node["setOpacity"] != null) {
                node["setOpacity"](0);
                var action = cc.FadeIn.create(time);
                node.runAction(action);
            }
            var children = node.getChildren();
            for (var i = 0; i < children.length; i++) {
                Utils.AllFadeIn(children[i], time);
            }
        };

        Utils.AllFadeOut = function (node, time) {
            if (node["setOpacity"] != null) {
                var action = cc.FadeOut.create(time);
                node.runAction(action);
            }
            var children = node.getChildren();
            for (var i = 0; i < children.length; i++) {
                Utils.AllFadeOut(children[i], time);
            }
        };

        Utils.MaxPoint = function (p1, p2) {
            var tempPoint = new cc.Point(0, 0);
            tempPoint.x = p1.x > p2.x ? p1.x : p2.x;
            tempPoint.y = p1.y > p2.y ? p1.y : p2.y;
            return tempPoint;
        };

        Utils.MinPoint = function (p1, p2) {
            var tempPoint = new cc.Point(0, 0);
            tempPoint.x = p1.x < p2.x ? p1.x : p2.x;
            tempPoint.y = p1.y < p2.y ? p1.y : p2.y;
            return tempPoint;
        };

        Utils.GetRectScale = function (soucreWH, targetWH) {
            var xScale = targetWH.x / soucreWH.x;
            var yScale = targetWH.y / soucreWH.y;
            return xScale < yScale ? xScale : yScale;
        };

        Utils.GetRealPixBitmapData = function (bmd) {
            var tempBmd;
            var data = bmd.getData();
            var width = bmd.getWidth();
            var height = bmd.getHeight();
            var minPoint = new cc.Point(width, height);
            var maxPoint = new cc.Point(0, 0);
            for (var i = 0; i < width; i++) {
                for (var j = 0; j < height; j++) {
                    var a = data[((j * width + i) * 4) + 3];
                    if (a != 0) {
                        maxPoint = tx.Utils.MaxPoint(maxPoint, new cc.Point(i, j));
                        minPoint = tx.Utils.MinPoint(minPoint, new cc.Point(i, j));
                    }
                }
            }

            var newWidth = maxPoint.x - minPoint.x;
            var newHeight = maxPoint.y - minPoint.y;

            tempBmd = new tx.BitmapData(newWidth, newHeight, true, 0);
            var tempData = tempBmd.getData();
            for (var i = 0; i < newWidth; i++) {
                for (var j = 0; j < newHeight; j++) {
                    tempData[((j * newWidth + i) * 4)] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4)];
                    tempData[((j * newWidth + i) * 4) + 1] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4) + 1];
                    tempData[((j * newWidth + i) * 4) + 2] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4) + 2];
                    tempData[((j * newWidth + i) * 4) + 3] = data[(((j + minPoint.y) * width + i + minPoint.x) * 4) + 3];
                }
            }
            tempBmd.setData(tempData);
            return tempBmd;
        };

        Utils.removeFullPathForFilename = function (filename) {
            var searchResolutionsOrderArray = cc.FileUtils.getInstance().getSearchResolutionsOrder();
            var searchPath = cc.FileUtils.getInstance().getSearchPath();
            for (var key in searchResolutionsOrderArray) {
                filename = filename.replace(searchResolutionsOrderArray[key] + "/", "");
            }
            for (var key2 in searchPath) {
                var path = searchPath[key2];
                if (path.length > 0 && path.lastIndexOf('/') !== path.length - 1)
                    path += '/';
                filename = filename.replace(path, "");
            }
            return filename;
        };

        Utils.GetXmlDoc = function (path) {
            var fullPath = cc.FileUtils.getInstance().fullPathForFilename(path);
            var textxml = cc.SAXParser.getInstance().getList(fullPath);
            var xmlDoc = cc.SAXParser.getInstance()._parserXML(textxml, path);
            var plist = xmlDoc.documentElement;
            return plist;
        };
        return Utils;
    })();
    tx.Utils = Utils;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var Attach = (function () {
        function Attach() {
        }
        Attach.addSpriteFrames = function (plistName) {
            if (typeof plistName === "undefined") { plistName = null; }
            if (plistName != null && !Attach.plistAddCache[plistName]) {
                cc.SpriteFrameCache.getInstance().addSpriteFrames(plistName);
                Attach.plistAddCache[plistName] = true;
            }
        };

        /**
        * 从库中取得 Sprite
        * @param s 图片名(xxx.png)或者plist中子图片名
        */
        Attach.getSprite = function (s, plistName) {
            if (typeof plistName === "undefined") { plistName = null; }
            Attach.addSpriteFrames(plistName);
            var haveSpriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(s);
            if (haveSpriteFrame != undefined) {
                return cc.Sprite.createWithSpriteFrameName(s);
            } else {
                return cc.Sprite.create(s);
            }
        };

        Attach.getInteractiveSprite = function (s, plistName, fps) {
            if (typeof plistName === "undefined") { plistName = null; }
            if (typeof fps === "undefined") { fps = 12; }
            Attach.addSpriteFrames(plistName);
            var haveSpriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(s);
            var texture = cc.TextureCache.getInstance().textureForKey(s);
            if (haveSpriteFrame != undefined) {
                return tx.InteractiveSprite.createWithSpriteFrame(haveSpriteFrame);
            } else if (texture != undefined) {
                return tx.InteractiveSprite.createWithTexture(texture);
            } else {
                //否则就是拿MC
                return Attach.getMovieClip(s, plistName, fps);
            }
        };

        Attach.getMovieClip = function (s, plistName, fps) {
            if (typeof plistName === "undefined") { plistName = null; }
            if (typeof fps === "undefined") { fps = 12; }
            if (plistName == null) {
                plistName = tx.TextureAtlas.FindPlistInDict(s);
            }
            if (plistName == null) {
                throw new Error("plistName is null");
            }
            var t = new tx.TextureAtlas(plistName);
            var a = t.getTextures(s);
            if (a.length > 0) {
                return new tx.MovieClip(a, fps);
            } else {
                throw new Error("have not MovieClip" + s);
            }
        };

        /**
        * 从库中取得 BitmapData
        * @param s BitmapData在库中绑定的类名
        * @param repeatedUse_NoChange 这个BitmapData被多次使用且不会被修改时请打开此选项,这有助于节约内存资源,请不要dispose该对象,清理请使用clearBitmapDataCache()
        * @param: plistName_soucre  plistName或者soucre
        */
        Attach.getBitmapData = function (s, repeatedUse_NoChange, plistName_soucre) {
            if (typeof repeatedUse_NoChange === "undefined") { repeatedUse_NoChange = false; }
            if (typeof plistName_soucre === "undefined") { plistName_soucre = null; }
            if (repeatedUse_NoChange) {
                if (!Attach.bitMapDataArray) {
                    Attach.bitMapDataArray = {};
                }
                if (Attach.bitMapDataArray[s] != null) {
                    //如果无效的BITMAP DATA(已被dispose),则删除
                    //						if((Attach.bitMapDataArray[i][1] as BitmapData).width == 0 && (Attach.bitMapDataArray[i][1] as BitmapData).height == 0)
                    //						{
                    //							Attach.bitMapDataArray.splice(i, 1);
                    //							break;
                    //						}
                    //						else
                    //						{
                    //找到了返回
                    //                    trace("yes")
                    return Attach.bitMapDataArray[s];
                    //						}
                }
                //找不到就创建新的
            }

            // var temp:Class;
            var tempMc;
            var offset = cc.p(0, 0);
            if (plistName_soucre instanceof cc.Node) {
                //如果是图片的话
                tempMc = plistName_soucre;
            } else {
                Attach.addSpriteFrames(plistName_soucre);
                var spriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(s);
                if (spriteFrame != undefined) {
                    tempMc = cc.Sprite.createWithSpriteFrameName(s);
                    offset = spriteFrame.getOffset();
                } else {
                    tempMc = cc.Sprite.create(s);
                }
            }
            tempMc.setAnchorPoint(cc.p(0, 1));

            //拍图片
            var rect = tempMc.getBoundingBox();

            //            console.log(rect.width+" "+tempMc.getTexture().getPixelsWide()+" "+tempMc.getContentSize().width);
            //            var filePath:string = "zhuangshi.plist"
            //            trace("============================", filePath,s);
            //            var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(filePath);
            //            if (dict) {
            //                var framesDict = dict["frames"];
            //                for (var key in framesDict) {
            //                    trace("key::::",key);
            //                    var frameDict = framesDict[s];
            //                    if (frameDict) {
            //            trace(offset.x, offset.y);
            //                    }
            //                }
            //            }else{
            //                trace("no dict");
            //            }
            //            trace(tempMc.getOffset().x,tempMc.getOffset().y);
            var returnBmd = new tx.BitmapData(rect.width, rect.height, true, 0);
            returnBmd.draw(tempMc, new tx.Matrix(1, 0, 0, 1, -offset.x, -offset.y));

            //        var returnObj : BitmapData = new temp(null, null);
            if (repeatedUse_NoChange) {
                Attach.bitMapDataArray[s] = returnBmd;
            }
            return returnBmd;
        };

        /**
        * 不能在
        */
        Attach.clearBitmapDataCache = function () {
            for (var i = 0; i < Attach.bitMapDataArray.length; i++) {
                Attach.bitMapDataArray[i][1].dispose();
            }
            Attach.bitMapDataArray = {};
        };
        Attach.bitMapDataArray = {};
        Attach.plistAddCache = {};
        return Attach;
    })();
    tx.Attach = Attach;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var AbstractRail = (function () {
        function AbstractRail() {
            if (getQualifiedClassName(this) == "zlong::breathxue::utils::RailMap::AbstractRail") {
                throw Error("can't be constructed");
            }
        }
        AbstractRail.prototype.destroy = function () {
        };

        AbstractRail.prototype.getDistance = function () {
            return 0;
        };

        AbstractRail.prototype.getPointByDistance = function (distance) {
            distance;
            return null;
        };

        AbstractRail.prototype.getRotationByDistance = function (distance) {
            distance;
            return 0;
        };

        AbstractRail.prototype.startPoint = function () {
            return null;
        };

        AbstractRail.prototype.endPoint = function () {
            return null;
        };

        AbstractRail.prototype.setDebugMc = function (mc) {
        };
        return AbstractRail;
    })();
    tx.AbstractRail = AbstractRail;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var Car = (function () {
        function Car(startDistance) {
            if (typeof startDistance === "undefined") { startDistance = 0; }
            this.distance = startDistance;
        }
        Car.prototype.destroy = function () {
            if (this._tdebugMc) {
                this._tdebugMc.getParent().removeChild(this._tdebugMc);
                this._tdebugMc = null;
            }
            this.railMap = null;
        };

        /**
        * 前进
        */
        Car.prototype.forward = function (distance) {
            if (!this.railMap) {
                return;
            }
            this.distance += distance;
        };

        /**
        * 后退
        */
        Car.prototype.back = function (distance) {
            if (!this.railMap) {
                return;
            }
            this.distance -= distance;
        };

        /**
        * 车子是否出轨
        */
        Car.prototype.isDerailed = function () {
            if (!this.railMap) {
                return 1;
            }
            if (!this.railMap.isCircular) {
                if (this.distance > this.railMap.totalDistance) {
                    return 1;
                }
                if (this.distance < 0) {
                    return -1;
                }
            }

            return 0;
        };

        /**
        * debug显示车子
        */
        Car.prototype.print = function () {
            if (this._tdebugMc) {
                this._tdebugMc.setPosition(this.getX(), this.getY());
                this._tdebugMc.setRotation(this.getRotation());
            }
        };

        Car.prototype.getX = function () {
            if (this.railMap == null) {
                return 0;
            } else {
                return this.railMap.getPoint(this).x;
            }
        };

        Car.prototype.getY = function () {
            if (this.railMap == null) {
                return 0;
            } else {
                return this.railMap.getPoint(this).y;
            }
        };

        Car.prototype.getRotation = function () {
            if (this.railMap == null) {
                return 0;
            } else {
                return this.railMap.getRotation(this);
            }
        };

        Car.prototype.setDebugMc = function (pmc) {
            this._tdebugMc = new cc.Node();
            pmc.addChild(this._tdebugMc);

            //            this._tdebugMc.graphics.beginFill(0x990000);
            //            this._tdebugMc.graphics.drawRect(-3, -2, 6, 4);
            //            this._tdebugMc.graphics.endFill();
            this.print();
        };
        return Car;
    })();
    tx.Car = Car;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var CurveRail = (function (_super) {
        __extends(CurveRail, _super);
        function CurveRail(p0x, p0y, p1x, p1y, p2x, p2y) {
            _super.call(this);
            this.p0 = new tx.mVector(p0x, p0y);
            this.p1 = new tx.mVector(p1x, p1y);
            this.p2 = new tx.mVector(p2x, p2y);

            this.block();
        }
        CurveRail.prototype.block = function () {
            this.blockLengthArr = new Array();

            //总长一定小于p0到p1到p2的长度
            //1除以分段数(总长除以/每段大小)
            this._partT = 1 / ((this.p1.minus(this.p0).getLength() + this.p2.minus(this.p1).getLength()) / CurveRail.MINI_BLOCK);

            this._distance = 0;

            var tempLastPoint = new tx.mVector(this.p0.x, this.p0.y);
            var tempPoint = new tx.mVector(0, 0);
            for (var tempT = this._partT; tempT < 1; tempT += this._partT) {
                tempPoint.x = this.p0.x * Math.pow(1 - tempT, 2) + this.p1.x * 2 * tempT * (1 - tempT) + this.p2.x * tempT * tempT;
                tempPoint.y = this.p0.y * Math.pow(1 - tempT, 2) + this.p1.y * 2 * tempT * (1 - tempT) + this.p2.y * tempT * tempT;
                this.blockLengthArr.push(tempPoint.minus(tempLastPoint).getLength());
                this._distance += tempPoint.minus(tempLastPoint).getLength();
                tempLastPoint = tempPoint.clone();
            }
            //trace(blockLengthArr.length);
        };

        CurveRail.prototype.destroy = function () {
            if (this._tdebugMc) {
                this._tdebugMc.getParent().removeChild(this._tdebugMc);
                this._tdebugMc = null;
            }
            this.p0 = null;
            this.p1 = null;
            this.p2 = null;
            this.blockLengthArr = null;
        };

        CurveRail.prototype.getDistance = function () {
            return this._distance;
        };

        CurveRail.prototype.getPointByDistance = function (distance) {
            if (distance >= this.getDistance()) {
                return this.p2;
            }

            if (distance <= 0) {
                return this.p0;
            }
            var tempLength = 0;
            for (var i = 0; i < this.blockLengthArr.length; i++) {
                tempLength += this.blockLengthArr[i]; //累计长度
                if (tempLength >= distance) {
                    var tempT = i * this._partT;
                    var tempPoint = new tx.mVector(0, 0);
                    tempPoint.x = this.p0.x * Math.pow(1 - tempT, 2) + this.p1.x * 2 * tempT * (1 - tempT) + this.p2.x * tempT * tempT;
                    tempPoint.y = this.p0.y * Math.pow(1 - tempT, 2) + this.p1.y * 2 * tempT * (1 - tempT) + this.p2.y * tempT * tempT;
                    return tempPoint;
                }
            }

            return this.p2;
        };

        CurveRail.prototype.getRotationByDistance = function (distance) {
            if (distance >= this.getDistance()) {
                return this.p2.minus(this.p1).getAngle();
            }

            if (distance <= 0) {
                return this.p1.minus(this.p0).getAngle();
            }

            var tempLength = 0;
            for (var i = 0; i < this.blockLengthArr.length; i++) {
                tempLength += this.blockLengthArr[i]; //累计长度
                if (tempLength >= distance) {
                    var tempT = i * this._partT;
                    var tempPointP0_P1 = new tx.mVector(0, 0);
                    var tempPointP1_P2 = new tx.mVector(0, 0);
                    tempPointP0_P1.x = this.p0.x + (this.p1.x - this.p0.x) * tempT;
                    tempPointP0_P1.y = this.p0.y + (this.p1.y - this.p0.y) * tempT;
                    tempPointP1_P2.x = this.p1.x + (this.p2.x - this.p1.x) * tempT;
                    tempPointP1_P2.y = this.p1.y + (this.p2.y - this.p1.y) * tempT;
                    return tempPointP1_P2.minus(tempPointP0_P1).getAngle();
                }
            }

            return this.p2.minus(this.p1).getAngle();
        };

        CurveRail.prototype.startPoint = function () {
            return this.p0;
        };

        CurveRail.prototype.endPoint = function () {
            return this.p2;
        };

        CurveRail.prototype.setDebugMc = function (pmc) {
            this._tdebugMc = new cc.Node();
            pmc.addChild(this._tdebugMc);
            //            this._tdebugMc.graphics.lineStyle(1, 0x000099);
            //            this._tdebugMc.graphics.moveTo(this.p0.x, this.p0.y);
            //            this._tdebugMc.graphics.curveTo(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
        };
        CurveRail.MINI_BLOCK = 1;
        return CurveRail;
    })(tx.AbstractRail);
    tx.CurveRail = CurveRail;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var LineRail = (function (_super) {
        __extends(LineRail, _super);
        function LineRail(sx, sy, ex, ey) {
            _super.call(this);
            this.sp = new tx.mVector(sx, sy);
            this.ep = new tx.mVector(ex, ey);
        }
        LineRail.prototype.destroy = function () {
            if (this._tdebugMc) {
                this._tdebugMc.getParent().removeChild(this._tdebugMc);
                this._tdebugMc = null;
            }
            this.sp = null;
            this.ep = null;
        };

        LineRail.prototype.getDistance = function () {
            return this.ep.minus(this.sp).getLength();
        };

        LineRail.prototype.getPointByDistance = function (distance) {
            if (distance >= this.getDistance()) {
                return this.ep;
            }
            if (distance <= 0) {
                return this.sp;
            }
            var tempPoint = this.ep.minus(this.sp);
            tempPoint.setLength(distance); //获得目标点相对于开始点的位置;
            return tempPoint.plusEquals(this.sp);
        };

        LineRail.prototype.getRotationByDistance = function (distance) {
            distance;
            return this.ep.minus(this.sp).getAngle();
        };

        LineRail.prototype.startPoint = function () {
            return this.sp;
        };

        LineRail.prototype.endPoint = function () {
            return this.ep;
        };

        LineRail.prototype.setDebugMc = function (pmc) {
            this._tdebugMc = new cc.Node();
            pmc.addChild(this._tdebugMc);
            //            this._tdebugMc.graphics.lineStyle(1, 0x000099);
            //            this._tdebugMc.graphics.moveTo(this.sp.x, this.sp.y);
            //            this._tdebugMc.graphics.lineTo(this.ep.x, this.ep.y);
        };
        return LineRail;
    })(tx.AbstractRail);
    tx.LineRail = LineRail;
})(tx || (tx = {}));
///<reference path='../ImportTS.d.ts' />
var tx;
(function (tx) {
    var RailMap = (function () {
        function RailMap(debugPmc) {
            if (typeof debugPmc === "undefined") { debugPmc = null; }
            if (RailMap.__debug__) {
                this._debugMc = new cc.Node();
                debugPmc.addChild(this._debugMc);
            }
            this.isCircular = false;
            this._railArr = [];
        }
        /**
        * 删除轨道地图
        */
        RailMap.prototype.destroy = function () {
            for (var i = 0; i < this._railArr.length; i++) {
                (this._railArr[i]).destroy();
            }
            this._railArr = null;
            if (this._debugMc) {
                this._debugMc.getParent().removeChild(this._debugMc);
                this._debugMc = null;
            }
        };

        /**
        * 添加车子,车子添加后才能开
        */
        RailMap.prototype.addCar = function (car) {
            car.railMap = this;
            if (RailMap.__debug__ && this._debugMc) {
                car.setDebugMc(this._debugMc);
            }
        };

        RailMap.prototype.setRails = function (_railArr) {
            this.totalDistance = 0;
            _railArr = new Array();
            for (var j = 0; j < _railArr.length; j++) {
                var tempRail = _railArr[j];
                if (tempRail) {
                    _railArr.push(tempRail);
                    if (RailMap.__debug__ && this._debugMc) {
                        tempRail.setDebugMc(this._debugMc);
                    }
                    this.totalDistance += tempRail.getDistance();
                }
            }
        };

        RailMap.prototype.getRails = function () {
            return this._railArr;
        };

        /**
        * 获得车厢当前的位置
        */
        RailMap.prototype.getPoint = function (car) {
            if (!this._railArr || this._railArr.length == 0) {
                return new tx.mVector();
            }
            if (car.isDerailed() < 0) {
                return (this._railArr[0]).getPointByDistance(0);
            }
            if (car.isDerailed() > 0) {
                //最后个轨道的最后
                return (this._railArr[this._railArr.length - 1]).getPointByDistance((this._railArr[this._railArr.length - 1]).getDistance());
            }

            //获得绝对距离
            var carDistance = car.distance % this.totalDistance;

            //循环负值的情况
            carDistance = carDistance >= 0 ? carDistance : this.totalDistance + carDistance;

            var tempDistance = 0;
            for (var i = 0; i < this._railArr.length; i++) {
                var tempRail = this._railArr[i];
                tempDistance += tempRail.getDistance();
                if (tempDistance > carDistance) {
                    return tempRail.getPointByDistance(carDistance - (tempDistance - tempRail.getDistance()));
                }
            }
            return new tx.mVector();
        };

        /**
        * 获得车厢当前的角度
        */
        RailMap.prototype.getRotation = function (car) {
            if (!this._railArr || this._railArr.length == 0) {
                return 0;
            }
            if (car.isDerailed() < 0) {
                return (this._railArr[0]).getRotationByDistance(0);
            }
            if (car.isDerailed() > 0) {
                //最后个轨道的最后
                return (this._railArr[this._railArr.length - 1]).getRotationByDistance((this._railArr[this._railArr.length - 1]).getDistance());
            }

            //获得绝对距离
            var carDistance = car.distance % this.totalDistance;

            //循环负值的情况
            carDistance = carDistance >= 0 ? carDistance : this.totalDistance + carDistance;

            var tempDistance = 0;
            for (var i = 0; i < this._railArr.length; i++) {
                var tempRail = this._railArr[i];
                tempDistance += tempRail.getDistance();
                if (tempDistance > carDistance) {
                    return tempRail.getRotationByDistance(carDistance - (tempDistance - tempRail.getDistance()));
                }
            }
            return 0;
        };
        RailMap.__debug__ = false;
        return RailMap;
    })();
    tx.RailMap = RailMap;
})(tx || (tx = {}));
